"""
SendBaba Email Tasks
====================
Celery tasks for email campaigns with full tracking integration
Using the working relay_server for actual sending
"""
import os
import sys
import uuid
import logging
from datetime import datetime

sys.path.insert(0, '/opt/sendbaba-staging')

from celery_app import celery_app
from app.smtp.relay_server import send_email_sync
from app.services.email_tracker import prepare_email_for_tracking

logger = logging.getLogger(__name__)


def get_db_connection():
    """Get database connection"""
    import psycopg2
    return psycopg2.connect(
        host='localhost',
        database='emailer',
        user='emailer',
        password='SecurePassword123'
    )


def personalize(content: str, contact: dict) -> str:
    """Replace merge tags with contact data"""
    if not content:
        return content
    
    replacements = {
        '{{first_name}}': contact.get('first_name', ''),
        '{{last_name}}': contact.get('last_name', ''),
        '{{email}}': contact.get('email', ''),
        '{{FIRST_NAME}}': contact.get('first_name', ''),
        '{{LAST_NAME}}': contact.get('last_name', ''),
        '*|FNAME|*': contact.get('first_name', ''),
        '*|LNAME|*': contact.get('last_name', ''),
        '*|EMAIL|*': contact.get('email', ''),
    }
    
    for tag, value in replacements.items():
        content = content.replace(tag, str(value or ''))
    
    return content


@celery_app.task(bind=True, max_retries=3)
def send_campaign(self, campaign_id: str):
    """
    Send a campaign with full tracking using relay_server
    """
    logger.info(f"üöÄ Starting campaign {campaign_id}")
    
    conn = get_db_connection()
    cursor = conn.cursor()
    
    stats = {'sent': 0, 'failed': 0, 'skipped': 0, 'total': 0}
    
    try:
        # Get campaign
        cursor.execute("""
            SELECT id, organization_id, name, from_name, from_email,
                   subject, html_body, text_body, reply_to
            FROM campaigns WHERE id = %s
        """, (campaign_id,))
        
        row = cursor.fetchone()
        if not row:
            logger.error(f"Campaign {campaign_id} not found")
            return {'success': False, 'error': 'Campaign not found'}
        
        campaign = {
            'id': row[0],
            'organization_id': row[1],
            'name': row[2],
            'from_name': row[3],
            'from_email': row[4],
            'subject': row[5],
            'html_body': row[6],
            'text_body': row[7],
            'reply_to': row[8]
        }
        
        # Update status to sending
        cursor.execute("""
            UPDATE campaigns 
            SET status = 'sending', started_at = NOW(), updated_at = NOW()
            WHERE id = %s
        """, (campaign_id,))
        conn.commit()
        
        # Get contacts
        cursor.execute("""
            SELECT id, email, first_name, last_name
            FROM contacts
            WHERE organization_id = %s AND status = 'active'
            ORDER BY id
        """, (campaign['organization_id'],))
        
        contacts = cursor.fetchall()
        stats['total'] = len(contacts)
        
        logger.info(f"üìß Sending {campaign['name']} to {stats['total']} contacts")
        
        for contact_row in contacts:
            contact = {
                'id': contact_row[0],
                'email': contact_row[1],
                'first_name': contact_row[2],
                'last_name': contact_row[3]
            }
            
            to_email = (contact['email'] or '').strip().lower()
            
            if not to_email or '@' not in to_email:
                stats['skipped'] += 1
                continue
            
            # Personalize content
            subject = personalize(campaign['subject'], contact)
            html_body = personalize(campaign['html_body'], contact)
            text_body = personalize(campaign['text_body'], contact) if campaign['text_body'] else ''
            
            # Generate email ID
            email_id = str(uuid.uuid4())
            
            # Inject tracking into HTML
            if html_body:
                try:
                    html_body, tracking_id = prepare_email_for_tracking(
                        html_body=html_body,
                        email_id=email_id,
                        org_id=campaign['organization_id'],
                        campaign_id=campaign_id,
                        recipient=to_email
                    )
                except:
                    tracking_id = None
            else:
                tracking_id = None
            
            # Create email record
            try:
                cursor.execute("""
                    INSERT INTO emails (id, organization_id, campaign_id, from_email, to_email,
                                       sender, recipient, subject, html_body, text_body,
                                       status, tracking_id, created_at)
                    VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, 'sending', %s, NOW())
                    ON CONFLICT (id) DO NOTHING
                """, (email_id, campaign['organization_id'], campaign_id,
                      campaign['from_email'], to_email, campaign['from_email'], to_email,
                      subject, html_body, text_body, tracking_id))
                conn.commit()
            except Exception as e:
                logger.warning(f"DB insert error: {e}")
                conn.rollback()
            
            # Send using relay_server (THE WORKING ONE!)
            try:
                result = send_email_sync({
                    'from': campaign['from_email'],
                    'from_name': campaign['from_name'],
                    'to': to_email,
                    'subject': subject,
                    'html_body': html_body,
                    'text_body': text_body,
                    'reply_to': campaign['reply_to']
                })
                
                if result.get('success'):
                    cursor.execute("""
                        UPDATE emails SET status = 'sent', sent_at = NOW() WHERE id = %s
                    """, (email_id,))
                    stats['sent'] += 1
                else:
                    error_msg = result.get('message', 'Unknown error')[:500]
                    cursor.execute("""
                        UPDATE emails SET status = 'failed', error_message = %s WHERE id = %s
                    """, (error_msg, email_id))
                    stats['failed'] += 1
                    
            except Exception as e:
                logger.warning(f"‚ùå Send error {to_email}: {e}")
                cursor.execute("""
                    UPDATE emails SET status = 'failed', error_message = %s WHERE id = %s
                """, (str(e)[:500], email_id))
                stats['failed'] += 1
            
            conn.commit()
            
            # Update progress every 50 emails
            if (stats['sent'] + stats['failed']) % 50 == 0:
                cursor.execute("""
                    UPDATE campaigns SET emails_sent = %s, updated_at = NOW() WHERE id = %s
                """, (stats['sent'], campaign_id))
                conn.commit()
                logger.info(f"üìä Progress: {stats['sent']} sent, {stats['failed']} failed")
        
        # Update final stats
        final_status = 'completed' if stats['failed'] < stats['total'] * 0.5 else 'completed_with_errors'
        cursor.execute("""
            UPDATE campaigns 
            SET status = %s, emails_sent = %s, sent_count = %s,
                sent_at = NOW(), updated_at = NOW()
            WHERE id = %s
        """, (final_status, stats['sent'], stats['sent'], campaign_id))
        conn.commit()
        
        logger.info(f"‚úÖ Campaign {campaign['name']} completed: {stats['sent']} sent, {stats['failed']} failed")
        
        return {
            'success': True,
            'campaign_id': campaign_id,
            'sent': stats['sent'],
            'failed': stats['failed'],
            'skipped': stats['skipped'],
            'total': stats['total']
        }
        
    except Exception as e:
        logger.error(f"Campaign error: {e}", exc_info=True)
        cursor.execute("""
            UPDATE campaigns SET status = 'failed', updated_at = NOW() WHERE id = %s
        """, (campaign_id,))
        conn.commit()
        return {'success': False, 'error': str(e)}
    finally:
        cursor.close()
        conn.close()


@celery_app.task
def send_single_email_task(email_id: str):
    """Send a single email from the queue"""
    conn = get_db_connection()
    cursor = conn.cursor()
    
    try:
        cursor.execute("""
            SELECT id, recipient_email, subject, html_body, body, 
                   organization_id, sender_user_id
            FROM single_emails WHERE id = %s
        """, (email_id,))
        
        row = cursor.fetchone()
        if not row:
            return {'success': False, 'error': 'Email not found'}
        
        email_data = {
            'id': row[0],
            'to': row[1],
            'subject': row[2],
            'html_body': row[3],
            'text_body': row[4],
            'org_id': row[5]
        }
        
        # Get sender domain
        cursor.execute("""
            SELECT domain_name FROM domains WHERE organization_id = %s LIMIT 1
        """, (email_data['org_id'],))
        domain_row = cursor.fetchone()
        from_email = f"noreply@{domain_row[0]}" if domain_row else 'noreply@sendbaba.com'
        
        # Send using relay_server
        result = send_email_sync({
            'from': from_email,
            'to': email_data['to'],
            'subject': email_data['subject'],
            'html_body': email_data['html_body'],
            'text_body': email_data['text_body'] or ''
        })
        
        if result.get('success'):
            cursor.execute("""
                UPDATE single_emails SET status = 'sent', sent_at = NOW() WHERE id = %s
            """, (email_id,))
            conn.commit()
            return {'success': True}
        else:
            cursor.execute("""
                UPDATE single_emails SET status = 'failed' WHERE id = %s
            """, (email_id,))
            conn.commit()
            return {'success': False, 'error': result.get('message')}
            
    except Exception as e:
        logger.error(f"Single email error: {e}")
        return {'success': False, 'error': str(e)}
    finally:
        cursor.close()
        conn.close()


@celery_app.task
def process_queued_campaigns():
    """Process campaigns in 'queued' status"""
    conn = get_db_connection()
    cursor = conn.cursor()
    
    try:
        cursor.execute("""
            SELECT id, name FROM campaigns
            WHERE status = 'queued'
            ORDER BY created_at ASC
            LIMIT 3
        """)
        
        campaigns = cursor.fetchall()
        
        for campaign_id, name in campaigns:
            logger.info(f"üîÑ Triggering queued campaign: {name}")
            send_campaign.delay(campaign_id)
        
        return {'processed': len(campaigns)}
    finally:
        cursor.close()
        conn.close()


@celery_app.task
def process_queued_single_emails():
    """Process single emails in 'queued' status"""
    conn = get_db_connection()
    cursor = conn.cursor()
    
    try:
        cursor.execute("""
            SELECT id FROM single_emails
            WHERE status = 'queued'
            ORDER BY created_at ASC
            LIMIT 50
        """)
        
        emails = cursor.fetchall()
        count = 0
        
        for (email_id,) in emails:
            send_single_email_task.delay(email_id)
            count += 1
        
        if count > 0:
            logger.info(f"üì¨ Queued {count} single emails for sending")
        
        return {'queued_count': count}
    finally:
        cursor.close()
        conn.close()


@celery_app.task
def sync_tracking_to_db():
    """Sync tracking data from Redis to PostgreSQL"""
    import redis
    
    try:
        r = redis.Redis(
            host='localhost', 
            port=6379, 
            password='SendBaba2024SecureRedis',
            decode_responses=True
        )
        
        conn = get_db_connection()
        cursor = conn.cursor()
        
        # Get all tracking keys
        keys = r.keys('track:*')
        synced = 0
        
        for key in keys[:100]:  # Process 100 at a time
            try:
                data = r.hgetall(key)
                if not data:
                    continue
                
                email_id = data.get('email_id')
                if not email_id:
                    continue
                
                # Update opens
                if data.get('opened'):
                    cursor.execute("""
                        UPDATE emails 
                        SET status = CASE WHEN status = 'sent' THEN 'opened' ELSE status END,
                            opened_at = COALESCE(opened_at, NOW()),
                            open_count = COALESCE(open_count, 0) + 1
                        WHERE id = %s
                    """, (email_id,))
                
                # Update clicks
                if data.get('clicked'):
                    cursor.execute("""
                        UPDATE emails 
                        SET status = 'clicked',
                            clicked_at = COALESCE(clicked_at, NOW()),
                            click_count = COALESCE(click_count, 0) + 1
                        WHERE id = %s
                    """, (email_id,))
                
                conn.commit()
                r.delete(key)
                synced += 1
                
            except Exception as e:
                logger.warning(f"Sync error for {key}: {e}")
                conn.rollback()
        
        cursor.close()
        conn.close()
        
        logger.info(f"üìä Synced {synced} tracking records to database")
        return {'synced': synced}
        
    except Exception as e:
        logger.error(f"Tracking sync error: {e}")
        return {'synced': 0, 'error': str(e)}
