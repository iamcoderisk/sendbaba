"""
SendBaba Email Tasks - Production Ready v2
==========================================
Features:
- Email validation & auto-correction
- Gmail throttling protection
- Real-time progress monitoring
- Stuck campaign recovery
- Direct campaign execution
"""
import os
import sys
import uuid
from concurrent.futures import ThreadPoolExecutor, as_completed
import logging
import time
import redis
from datetime import datetime, timedelta

sys.path.insert(0, '/opt/sendbaba-staging')

from celery_app import celery_app
from app.smtp.relay_server import send_email_sync
from app.services.email_tracker import prepare_email_for_tracking

logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO)

# Redis for progress tracking
redis_client = redis.Redis(host='localhost', port=6379, password='SendBabaRedis2024!', decode_responses=True)

# Gmail throttling settings
GMAIL_THROTTLE = {
    'per_minute': 60,      # Max Gmail emails per minute per IP
    'per_hour': 1500,      # Max Gmail emails per hour per IP
    'delay_ms': 100,       # Delay between Gmail sends (milliseconds)
}


def get_db_connection():
    """Get database connection"""
    import psycopg2
    return psycopg2.connect(
        host='localhost',
        database='emailer',
        user='emailer',
        password='SecurePassword123'
    )


def validate_and_fix_email(email):
    """Validate and auto-correct email typos"""
    try:
        from app.utils.email_validator import validate_email
        is_valid, corrected, reason = validate_email(email, check_mx=False, auto_fix=True)
        return is_valid, corrected, reason
    except Exception as e:
        if not email or '@' not in email:
            return False, email, 'invalid_format'
        return True, email.strip().lower(), None


def personalize(content: str, contact: dict) -> str:
    """Replace merge tags with contact data"""
    if not content:
        return content
    
    replacements = {
        '{{first_name}}': contact.get('first_name', ''),
        '{{last_name}}': contact.get('last_name', ''),
        '{{email}}': contact.get('email', ''),
        '{{FIRST_NAME}}': contact.get('first_name', ''),
        '{{LAST_NAME}}': contact.get('last_name', ''),
        '*|FNAME|*': contact.get('first_name', ''),
        '*|LNAME|*': contact.get('last_name', ''),
        '*|EMAIL|*': contact.get('email', ''),
    }
    
    for tag, value in replacements.items():
        content = content.replace(tag, str(value or ''))
    
    return content


def is_gmail(email):
    """Check if email is Gmail/Google"""
    domain = email.split('@')[-1].lower()
    return domain in ['gmail.com', 'googlemail.com'] or 'google' in domain


def check_gmail_throttle():
    """Check if we should throttle Gmail sends"""
    key = f"gmail_throttle:{datetime.now().strftime('%Y%m%d%H%M')}"
    count = redis_client.incr(key)
    redis_client.expire(key, 120)  # 2 minute TTL
    
    if count > GMAIL_THROTTLE['per_minute'] * 4:  # Across all IPs
        return True, count
    return False, count


def update_progress(campaign_id, sent, failed, total, status='sending'):
    """Update campaign progress in Redis for real-time monitoring"""
    key = f"campaign_progress:{campaign_id}"
    redis_client.hset(key, mapping={
        'sent': sent,
        'failed': failed,
        'total': total,
        'status': status,
        'percent': int((sent + failed) / total * 100) if total > 0 else 0,
        'updated_at': datetime.now().isoformat()
    })
    redis_client.expire(key, 86400)  # 24 hour TTL


def execute_campaign(campaign_id: str):
    """Execute a campaign with Gmail throttling and progress tracking"""
    logger.info(f"ðŸš€ Starting campaign {campaign_id}")
    
    conn = get_db_connection()
    cursor = conn.cursor()
    
    stats = {'sent': 0, 'failed': 0, 'skipped': 0, 'corrected': 0, 'total': 0, 'gmail_count': 0}
    
    try:
        # Get campaign
        cursor.execute("""
            SELECT id, organization_id, name, from_name, from_email,
                   subject, COALESCE(html_content, html_body, '') as html_body, text_body, reply_to
            FROM campaigns WHERE id = %s
        """, (campaign_id,))
        
        row = cursor.fetchone()
        if not row:
            logger.error(f"Campaign {campaign_id} not found")
            return {'success': False, 'error': 'Campaign not found'}
        
        campaign = {
            'id': row[0],
            'organization_id': row[1],
            'name': row[2],
            'from_name': row[3],
            'from_email': row[4],
            'subject': row[5],
            'html_body': row[6],
            'text_body': row[7],
            'reply_to': row[8]
        }
        
        # Update status to sending
        cursor.execute("""
            UPDATE campaigns 
            SET status = 'sending', started_at = NOW(), updated_at = NOW()
            WHERE id = %s
        """, (campaign_id,))
        conn.commit()
        
        # Get contacts
        cursor.execute("""
            SELECT id, email, first_name, last_name
            FROM contacts
            WHERE organization_id = %s AND status = 'active'
            ORDER BY id
        """, (campaign['organization_id'],))
        
        contacts = cursor.fetchall()
        stats['total'] = len(contacts)
        
        logger.info(f"ðŸ“§ Sending {campaign['name']} to {stats['total']} contacts")
        
        # Initialize progress
        update_progress(campaign_id, 0, 0, stats['total'], 'sending')
        
        start_time = time.time()
        
        # ============================================
        # PARALLEL EMAIL SENDING (50 concurrent threads)
        # ============================================
        PARALLEL_THREADS = 200
        
        def send_single_contact(contact_row, campaign_data, cid):
            """Send email to single contact - thread-safe"""
            from app.smtp.relay_server import send_email_sync
            thread_conn = get_db_connection()
            thread_cursor = thread_conn.cursor()
            res = {'sent': 0, 'failed': 0, 'skipped': 0, 'corrected': 0, 'gmail': 0}
            
            try:
                contact = {'id': contact_row[0], 'email': contact_row[1], 'first_name': contact_row[2], 'last_name': contact_row[3]}
                original_email = (contact['email'] or '').strip()
                is_valid, to_email, reason = validate_and_fix_email(original_email)
                
                if not is_valid:
                    res['skipped'] = 1
                    return res
                if to_email != original_email.lower():
                    res['corrected'] = 1
                if is_gmail(to_email):
                    res['gmail'] = 1
                
                subject = personalize(campaign_data['subject'], contact)
                html_body = personalize(campaign_data['html_body'], contact)
                text_body = personalize(campaign_data['text_body'], contact) if campaign_data['text_body'] else ''
                
                email_id = str(uuid.uuid4())
                tracking_id = None
                
                if html_body:
                    try:
                        html_body, tracking_id = prepare_email_for_tracking(html_body=html_body, email_id=email_id, org_id=campaign_data['organization_id'], campaign_id=cid, recipient=to_email)
                    except:
                        pass
                
                try:
                    thread_cursor.execute("""INSERT INTO emails (id, organization_id, campaign_id, from_email, to_email, sender, recipient, subject, html_body, text_body, status, tracking_id, created_at) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, 'sending', %s, NOW()) ON CONFLICT (id) DO NOTHING""", (email_id, campaign_data['organization_id'], cid, campaign_data['from_email'], to_email, campaign_data['from_email'], to_email, subject, html_body, text_body, tracking_id))
                    thread_conn.commit()
                except:
                    thread_conn.rollback()
                
                try:
                    send_result = send_email_sync({'from': campaign_data['from_email'], 'from_name': campaign_data['from_name'], 'to': to_email, 'subject': subject, 'html_body': html_body, 'text_body': text_body, 'reply_to': campaign_data['reply_to']})
                    if send_result.get('success'):
                        thread_cursor.execute("UPDATE emails SET status = 'sent', sent_at = NOW() WHERE id = %s", (email_id,))
                        res['sent'] = 1
                    else:
                        thread_cursor.execute("UPDATE emails SET status = 'failed', error_message = %s WHERE id = %s", (send_result.get('message', 'Error')[:500], email_id))
                        res['failed'] = 1
                except Exception as e:
                    thread_cursor.execute("UPDATE emails SET status = 'failed', error_message = %s WHERE id = %s", (str(e)[:500], email_id))
                    res['failed'] = 1
                thread_conn.commit()
            except:
                res['failed'] = 1
            finally:
                try:
                    thread_cursor.close()
                    thread_conn.close()
                except:
                    pass
            return res
        
        logger.info(f"ðŸš€ PARALLEL send: {PARALLEL_THREADS} threads, {stats['total']} contacts")
        
        with ThreadPoolExecutor(max_workers=PARALLEL_THREADS) as executor:
            futures = [executor.submit(send_single_contact, c, campaign, campaign_id) for c in contacts]
            completed = 0
            for future in as_completed(futures):
                try:
                    r = future.result(timeout=60)
                    stats['sent'] += r.get('sent', 0)
                    stats['failed'] += r.get('failed', 0)
                    stats['skipped'] += r.get('skipped', 0)
                    stats['corrected'] += r.get('corrected', 0)
                    stats['gmail_count'] += r.get('gmail', 0)
                except:
                    stats['failed'] += 1
                completed += 1
                if completed % 100 == 0 or completed == stats['total']:
                    update_progress(campaign_id, stats['sent'], stats['failed'], stats['total'])
                    elapsed = time.time() - start_time
                    rate = completed / elapsed if elapsed > 0 else 0
                    cursor.execute("UPDATE campaigns SET sent_count = %s, updated_at = NOW() WHERE id = %s", (stats['sent'], campaign_id))
                    conn.commit()
                    logger.info(f"ðŸ“Š Progress: {completed}/{stats['total']} ({rate:.1f}/sec)")
        
        
        # Final update
        elapsed = time.time() - start_time
        final_status = 'completed' if stats['failed'] < stats['total'] * 0.5 else 'completed_with_errors'
        
        cursor.execute("""
            UPDATE campaigns SET status = %s, sent_count = %s, sent_at = NOW(), updated_at = NOW() WHERE id = %s
        """, (final_status, stats['sent'], campaign_id))
        conn.commit()
        
        update_progress(campaign_id, stats['sent'], stats['failed'], stats['total'], final_status)
        
        logger.info(f"âœ… Campaign {campaign['name']} completed in {elapsed:.1f}s: {stats['sent']} sent, {stats['failed']} failed, {stats['gmail_count']} Gmail")
        
        return {
            'success': True, 
            'campaign_id': campaign_id, 
            'sent': stats['sent'], 
            'failed': stats['failed'], 
            'skipped': stats['skipped'], 
            'corrected': stats['corrected'], 
            'total': stats['total'],
            'gmail_count': stats['gmail_count'],
            'elapsed_seconds': int(elapsed)
        }
        
    except Exception as e:
        logger.error(f"Campaign error: {e}", exc_info=True)
        try:
            cursor.execute("UPDATE campaigns SET status = 'failed', updated_at = NOW() WHERE id = %s", (campaign_id,))
            conn.commit()
            update_progress(campaign_id, stats['sent'], stats['failed'], stats['total'], 'failed')
        except:
            pass
        return {'success': False, 'error': str(e)}
    finally:
        cursor.close()
        conn.close()


@celery_app.task(name='app.tasks.email_tasks.send_campaign', max_retries=3, soft_time_limit=7200)
def send_campaign(campaign_id: str):
    """Celery task wrapper for execute_campaign"""
    return execute_campaign(campaign_id)


@celery_app.task(name='app.tasks.email_tasks.send_single_email_task')
def send_single_email_task(email_data):
    """Send a single email"""
    conn = get_db_connection()
    cursor = conn.cursor()
    
    try:
        if isinstance(email_data, str):
            cursor.execute("""
                SELECT id, recipient_email, subject, html_body, body, organization_id
                FROM single_emails WHERE id = %s
            """, (email_data,))
            
            row = cursor.fetchone()
            if not row:
                return {'success': False, 'error': 'Email not found'}
            
            email_info = {'id': row[0], 'to': row[1], 'subject': row[2], 'html_body': row[3], 'text_body': row[4], 'org_id': row[5]}
            
            cursor.execute("SELECT domain_name FROM domains WHERE organization_id = %s LIMIT 1", (email_info['org_id'],))
            domain_row = cursor.fetchone()
            from_email = f"noreply@{domain_row[0]}" if domain_row else 'noreply@sendbaba.com'
            from_name = 'SendBaba'
        elif isinstance(email_data, dict):
            email_info = email_data
            from_email = email_data.get('from_email') or email_data.get('from') or 'noreply@sendbaba.com'
            from_name = email_data.get('from_name') or 'SendBaba'
        else:
            return {'success': False, 'error': f'Invalid email_data type'}
        
        to_email = email_info.get('to') or email_info.get('to_email')
        is_valid, to_email, reason = validate_and_fix_email(to_email)
        
        if not is_valid:
            return {'success': False, 'error': f'Invalid email: {reason}'}
        
        result = send_email_sync({
            'from': from_email, 'from_name': from_name, 'to': to_email,
            'subject': email_info.get('subject', ''), 
            'html_body': email_info.get('html_body', ''), 
            'text_body': email_info.get('text_body', '')
        })
        
        if isinstance(email_data, str):
            status = 'sent' if result.get('success') else 'failed'
            cursor.execute("UPDATE single_emails SET status = %s, sent_at = NOW() WHERE id = %s", (status, email_data))
            conn.commit()
        
        return result
    except Exception as e:
        logger.error(f"Single email error: {e}")
        return {'success': False, 'error': str(e)}
    finally:
        cursor.close()
        conn.close()


@celery_app.task(name='app.tasks.email_tasks.process_queued_campaigns')
def process_queued_campaigns():
    """Process campaigns in 'queued' status - executes DIRECTLY"""
    conn = get_db_connection()
    cursor = conn.cursor()
    
    try:
        cursor.execute("""
            SELECT id, name FROM campaigns
            WHERE status = 'queued'
            ORDER BY created_at ASC
            LIMIT 10
        """)
        
        campaigns = cursor.fetchall()
        processed = 0
        
        for campaign_id, name in campaigns:
            logger.info(f"ðŸ”„ Processing campaign: {name} ({campaign_id})")
            
            cursor.execute("""
                UPDATE campaigns 
                SET status = 'sending', started_at = NOW(), updated_at = NOW()
                WHERE id = %s AND status = 'queued'
                RETURNING id
            """, (campaign_id,))
            
            result = cursor.fetchone()
            conn.commit()
            
            if result:
                try:
                    execute_campaign(campaign_id)
                    processed += 1
                    logger.info(f"âœ… Completed campaign: {name}")
                except Exception as e:
                    logger.error(f"âŒ Campaign {name} failed: {e}")
                    cursor.execute("UPDATE campaigns SET status = 'failed', updated_at = NOW() WHERE id = %s", (campaign_id,))
                    conn.commit()
        
        if processed > 0:
            logger.info(f"ðŸ“‹ Processed {processed} campaigns")
        
        return {'processed': processed}
        
    except Exception as e:
        logger.error(f"process_queued_campaigns error: {e}")
        return {'processed': 0, 'error': str(e)}
    finally:
        cursor.close()
        conn.close()


@celery_app.task(name='app.tasks.email_tasks.recover_stuck_campaigns')
def recover_stuck_campaigns():
    """Recover campaigns stuck in 'sending' status"""
    conn = get_db_connection()
    cursor = conn.cursor()
    
    try:
        cursor.execute("""
            SELECT id, name FROM campaigns
            WHERE status = 'sending'
            AND updated_at < NOW() - INTERVAL '30 minutes'
            LIMIT 5
        """)
        
        stuck = cursor.fetchall()
        recovered = 0
        
        for campaign_id, name in stuck:
            logger.warning(f"âš ï¸ Recovering stuck campaign: {name}")
            
            cursor.execute("""
                SELECT COUNT(*) FILTER (WHERE status = 'sent') as sent,
                       COUNT(*) FILTER (WHERE status = 'failed') as failed
                FROM emails WHERE campaign_id = %s
            """, (campaign_id,))
            
            stats = cursor.fetchone()
            sent, failed = stats if stats else (0, 0)
            
            if sent == 0 and failed == 0:
                cursor.execute("UPDATE campaigns SET status = 'queued', started_at = NULL WHERE id = %s", (campaign_id,))
            else:
                final_status = 'completed' if failed < sent else 'completed_with_errors'
                cursor.execute("UPDATE campaigns SET status = %s, sent_count = %s WHERE id = %s", (final_status, sent, campaign_id))
            
            conn.commit()
            recovered += 1
        
        return {'recovered': recovered}
        
    except Exception as e:
        logger.error(f"recover_stuck_campaigns error: {e}")
        return {'recovered': 0, 'error': str(e)}
    finally:
        cursor.close()
        conn.close()


@celery_app.task(name='app.tasks.email_tasks.process_queued_single_emails')
def process_queued_single_emails():
    """Process single emails in 'queued' status"""
    conn = get_db_connection()
    cursor = conn.cursor()
    
    try:
        cursor.execute("SELECT id FROM single_emails WHERE status = 'queued' ORDER BY created_at ASC LIMIT 10000")
        emails = cursor.fetchall()
        count = 0
        
        for (email_id,) in emails:
            celery_app.send_task('app.tasks.email_tasks.send_single_email_task', args=[email_id], queue='celery')
            count += 1
        
        if count > 0:
            logger.info(f"ðŸ“¬ Queued {count} single emails")
        
        return {'queued_count': count}
    except Exception as e:
        logger.error(f"process_queued_single_emails error: {e}")
        return {'queued_count': 0, 'error': str(e)}
    finally:
        cursor.close()
        conn.close()


@celery_app.task(name='app.tasks.email_tasks.reset_daily_counters')
def reset_daily_counters():
    """Reset daily email counters"""
    conn = get_db_connection()
    cursor = conn.cursor()
    
    try:
        cursor.execute("""
            UPDATE ip_pools SET sent_today = 0, last_reset_at = NOW() 
            WHERE last_reset_at IS NULL OR last_reset_at::date < CURRENT_DATE
        """)
        count = cursor.rowcount
        conn.commit()
        
        if count > 0:
            logger.info(f"ðŸ”„ Reset daily counters for {count} IPs")
        
        return {'reset': count}
    except Exception as e:
        logger.error(f"reset_daily_counters error: {e}")
        return {'reset': 0, 'error': str(e)}
    finally:
        cursor.close()
        conn.close()


@celery_app.task(name='app.tasks.email_tasks.sync_tracking_to_db')
def sync_tracking_to_db():
    """Sync tracking data from Redis to PostgreSQL"""
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        
        keys = redis_client.keys('track:*')
        synced = 0
        
        for key in keys[:100]:
            try:
                data = redis_client.hgetall(key)
                if not data:
                    continue
                
                email_id = data.get('email_id')
                if not email_id:
                    continue
                
                if data.get('opened'):
                    cursor.execute("""
                        UPDATE emails SET status = CASE WHEN status = 'sent' THEN 'opened' ELSE status END,
                        opened_at = COALESCE(opened_at, NOW()), open_count = COALESCE(open_count, 0) + 1 WHERE id = %s
                    """, (email_id,))
                
                if data.get('clicked'):
                    cursor.execute("""
                        UPDATE emails SET status = 'clicked', clicked_at = COALESCE(clicked_at, NOW()),
                        click_count = COALESCE(click_count, 0) + 1 WHERE id = %s
                    """, (email_id,))
                
                conn.commit()
                redis_client.delete(key)
                synced += 1
            except Exception as e:
                conn.rollback()
        
        cursor.close()
        conn.close()
        
        if synced > 0:
            logger.info(f"ðŸ“Š Synced {synced} tracking records")
        return {'synced': synced}
    except Exception as e:
        logger.error(f"Tracking sync error: {e}")
        return {'synced': 0, 'error': str(e)}

# Fast parallel sender for large campaigns
@celery_app.task(name='app.tasks.email_tasks.fast_send_campaign', soft_time_limit=7200)
def fast_send_campaign_task(campaign_id: str, max_workers: int = 50):
    """High-speed parallel campaign sender"""
    from app.tasks.fast_sender import fast_send_campaign
    return fast_send_campaign(campaign_id, max_workers)
