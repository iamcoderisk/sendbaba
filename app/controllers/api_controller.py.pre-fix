from flask import Blueprint, request, jsonify, flash, redirect, url_for
from datetime import datetime
from flask_login import login_required, current_user
from app import db, redis_client
from sqlalchemy import text
import json
import uuid
import logging
from functools import wraps

logger = logging.getLogger(__name__)

api_bp = Blueprint('api', __name__, url_prefix='/api')

# API Key Authentication Decorator
def require_api_key(f):
    """Decorator for API key authentication"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        api_key = request.headers.get('X-API-Key')
        
        if not api_key:
            return jsonify({'success': False, 'error': 'API key required'}), 401
        
        try:
            result = db.session.execute(
                text("SELECT id, name FROM organizations WHERE api_key = :api_key"),
                {'api_key': api_key}
            )
            org = result.fetchone()
            
            if not org:
                return jsonify({'success': False, 'error': 'Invalid API key'}), 401
            
            request.org_id = org[0]
            request.org_name = org[1]
            
            return f(*args, **kwargs)
            
        except Exception as e:
            logger.error(f"API auth error: {e}")
            return jsonify({'success': False, 'error': 'Authentication failed'}), 500
    
    return decorated_function

# ============= DASHBOARD API ENDPOINTS (Login Required) =============

@api_bp.route('/emails/send', methods=['POST'])
@login_required
def send_email():
    """Send a single email via dashboard"""
    try:
        # Get form data
        from_name = request.form.get('from_name', '').strip()
        from_domain = request.form.get('from_domain', '').strip()
        to_email = request.form.get('to_email', '').strip()
        subject = request.form.get('subject', '').strip()
        html_body = request.form.get('html_body', '').strip()
        is_test = request.form.get('is_test', 'false').lower() == 'true'
        
        logger.info(f"üìß Email send request from user: {current_user.email}")
        logger.info(f"   From: {from_name}@{from_domain}")
        logger.info(f"   To: {to_email}")
        logger.info(f"   Subject: {subject}")
        
        # Validate
        if not all([from_name, from_domain, to_email, subject, html_body]):
            logger.error("‚ùå Missing required fields")
            return jsonify({'success': False, 'error': 'All fields are required'}), 400
        
        # Verify domain ownership
        domain = Domain.query.filter_by(
            domain_name=from_domain,
            organization_id=current_user.organization_id
        ).first()
        
        if not domain:
            logger.error(f"‚ùå Domain not found: {from_domain}")
            return jsonify({'success': False, 'error': f'Domain {from_domain} not authorized'}), 403
        
        # Build from email
        from_email = f"{from_name}@{from_domain}"
        
        # Create email record
        email_record = EmailOutgoing(
            organization_id=current_user.organization_id,
            from_email=from_email,
            to_email=to_email,
            subject=subject,
            body=html_body,
            html_body=html_body,
            status='queued',
            message_id=f"<{uuid.uuid4()}@{from_domain}>"
        )
        
        db.session.add(email_record)
        db.session.commit()
        
        logger.info(f"‚úÖ Email queued with ID: {email_record.id}")
        
        # Try to send immediately
        try:
            import smtplib
            from email.mime.text import MIMEText
            from email.mime.multipart import MIMEMultipart
            
            msg = MIMEMultipart('alternative')
            msg['Subject'] = subject
            msg['From'] = from_email
            msg['To'] = to_email
            msg['Message-ID'] = email_record.message_id
            
            # Add HTML part
            html_part = MIMEText(html_body, 'html')
            msg.attach(html_part)
            
            # Send via localhost SMTP (Postfix)
            with smtplib.SMTP('localhost', 25) as server:
                server.send_message(msg)
            
            # Update status
            email_record.status = 'sent'
            email_record.sent_at = datetime.utcnow()
            db.session.commit()
            
            logger.info(f"‚úÖ Email sent successfully (ID: {email_record.id})")
            
            return jsonify({
                'success': True,
                'message': 'Email sent successfully!',
                'email_id': email_record.id
            })
            
        except Exception as smtp_error:
            logger.error(f"‚ùå SMTP error: {smtp_error}", exc_info=True)
            email_record.status = 'failed'
            email_record.error_message = str(smtp_error)
            db.session.commit()
            
            return jsonify({
                'success': False,
                'error': f'Failed to send: {str(smtp_error)}'
            }), 500
        
    except Exception as e:
        logger.error(f"‚ùå Send email error: {e}", exc_info=True)
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@api_bp.route('/contacts/import', methods=['POST'])
@login_required
def import_contacts():
    """Import contacts from CSV"""
    try:
        if 'file' not in request.files:
            flash('No file uploaded', 'error')
            return redirect(url_for('contacts.list_contacts'))
        
        file = request.files['file']
        if not file.filename.endswith('.csv'):
            flash('Only CSV files allowed', 'error')
            return redirect(url_for('contacts.list_contacts'))
        
        import csv, io
        
        stream = io.StringIO(file.stream.read().decode("UTF8"), newline=None)
        csv_reader = csv.DictReader(stream)
        
        imported = 0
        for row in csv_reader:
            email = row.get('email', '').strip()
            name = row.get('name', '').strip()
            
            if not email:
                continue
            
            contact_id = str(uuid.uuid4())
            
            try:
                db.session.execute(
                    text("""
                        INSERT INTO contacts (id, organization_id, email, name, created_at)
                        VALUES (:id, :org_id, :email, :name, NOW())
                        ON CONFLICT DO NOTHING
                    """),
                    {'id': contact_id, 'org_id': current_user.organization_id, 'email': email, 'name': name}
                )
                imported += 1
            except:
                continue
        
        db.session.commit()
        flash(f'{imported} contacts imported', 'success')
        return redirect(url_for('contacts.list_contacts'))
        
    except Exception as e:
        db.session.rollback()
        logger.error(f"Import error: {e}", exc_info=True)
        flash('Import failed', 'error')
        return redirect(url_for('contacts.list_contacts'))

@api_bp.route('/contacts/<contact_id>/delete', methods=['POST'])
@login_required
def delete_contact(contact_id):
    """Delete a contact"""
    try:
        db.session.execute(
            text("DELETE FROM contacts WHERE id = :id AND organization_id = :org_id"),
            {'id': contact_id, 'org_id': current_user.organization_id}
        )
        db.session.commit()
        flash('Contact deleted', 'success')
        return redirect(url_for('contacts.list_contacts'))
    except Exception as e:
        db.session.rollback()
        flash('Delete failed', 'error')
        return redirect(url_for('contacts.list_contacts'))


# ============= PUBLIC API v1 ENDPOINTS (API Key Required) =============

@api_bp.route('/v1/send', methods=['POST'])
@require_api_key
def api_v1_send():
    """API v1 - Send single email"""
    try:
        data = request.get_json()
        
        to_email = data.get('to')
        from_email = data.get('from')
        subject = data.get('subject')
        html_body = data.get('html_body', '')
        text_body = data.get('text_body', '')
        
        if not all([to_email, from_email, subject]):
            return jsonify({'success': False, 'error': 'Missing required fields: to, from, subject'}), 400
        
        email_id = str(uuid.uuid4())
        
        # Save to database
        db.session.execute(
            text("""
                INSERT INTO emails (
                    id, organization_id, sender, recipient,
                    subject, html_body, status, created_at
                )
                VALUES (:id, :org_id, :sender, :recipient, :subject, :html_body, 'queued', NOW())
            """),
            {
                'id': email_id,
                'org_id': request.org_id,
                'sender': from_email,
                'recipient': to_email,
                'subject': subject,
                'html_body': html_body
            }
        )
        
        # Queue for sending
        email_data = {
            'id': email_id,
            'org_id': request.org_id,
            'from': from_email,
            'to': to_email,
            'subject': subject,
            'html_body': html_body,
            'text_body': text_body,
            'priority': 10
        }
        
        redis_client.lpush('outgoing_10', json.dumps(email_data))
        db.session.commit()
        
        logger.info(f"API: Email {email_id} queued for {to_email}")
        
        return jsonify({
            'success': True,
            'email_id': email_id,
            'message': 'Email queued successfully'
        })
        
    except Exception as e:
        db.session.rollback()
        logger.error(f"API v1 send error: {e}", exc_info=True)
        return jsonify({'success': False, 'error': str(e)}), 500

@api_bp.route('/v1/send/bulk', methods=['POST'])
@require_api_key
def api_v1_bulk_send():
    """API v1 - Send bulk emails"""
    try:
        data = request.get_json()
        emails = data.get('emails', [])
        
        if not emails:
            return jsonify({'success': False, 'error': 'No emails provided'}), 400
        
        if len(emails) > 10000:
            return jsonify({'success': False, 'error': 'Maximum 10,000 emails per request'}), 400
        
        queued_ids = []
        
        for email in emails:
            email_id = str(uuid.uuid4())
            
            db.session.execute(
                text("""
                    INSERT INTO emails (
                        id, organization_id, sender, recipient,
                        subject, html_body, status, created_at
                    )
                    VALUES (:id, :org_id, :sender, :recipient, :subject, :html_body, 'queued', NOW())
                """),
                {
                    'id': email_id,
                    'org_id': request.org_id,
                    'sender': email.get('from'),
                    'recipient': email.get('to'),
                    'subject': email.get('subject'),
                    'html_body': email.get('html_body', '')
                }
            )
            
            email_data = {
                'id': email_id,
                'org_id': request.org_id,
                'from': email.get('from'),
                'to': email.get('to'),
                'subject': email.get('subject'),
                'html_body': email.get('html_body', ''),
                'text_body': email.get('text_body', ''),
                'priority': 5
            }
            
            redis_client.lpush('outgoing_5', json.dumps(email_data))
            queued_ids.append(email_id)
        
        db.session.commit()
        
        logger.info(f"API: Bulk queued {len(queued_ids)} emails")
        
        return jsonify({
            'success': True,
            'queued': len(queued_ids),
            'email_ids': queued_ids
        })
        
    except Exception as e:
        db.session.rollback()
        logger.error(f"API v1 bulk send error: {e}", exc_info=True)
        return jsonify({'success': False, 'error': str(e)}), 500

@api_bp.route('/v1/usage', methods=['GET'])
@require_api_key
def api_v1_usage():
    """API v1 - Get usage stats"""
    try:
        result = db.session.execute(
            text("""
                SELECT 
                    COUNT(*) FILTER (WHERE created_at >= CURRENT_DATE) as today_sent,
                    COUNT(*) FILTER (WHERE created_at >= CURRENT_DATE - INTERVAL '30 days') as month_sent
                FROM emails
                WHERE organization_id = :org_id AND status = 'sent'
            """),
            {'org_id': request.org_id}
        )
        
        row = result.fetchone()
        
        return jsonify({
            'success': True,
            'usage': {
                'today': {'sent': row[0] or 0, 'failed': 0},
                'last_30_days': {'sent': row[1] or 0, 'failed': 0}
            }
        })
        
    except Exception as e:
        logger.error(f"API v1 usage error: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

@api_bp.route('/v1/contacts', methods=['GET', 'POST'])
@require_api_key
def api_v1_contacts():
    """API v1 - List or add contacts"""
    if request.method == 'GET':
        try:
            page = request.args.get('page', 1, type=int)
            per_page = min(request.args.get('per_page', 50, type=int), 100)
            
            result = db.session.execute(
                text("""
                    SELECT id, email, name, created_at
                    FROM contacts
                    WHERE organization_id = :org_id
                    ORDER BY created_at DESC
                    LIMIT :limit OFFSET :offset
                """),
                {'org_id': request.org_id, 'limit': per_page, 'offset': (page - 1) * per_page}
            )
            
            contacts = [{'id': r[0], 'email': r[1], 'name': r[2], 'created_at': r[3].isoformat()} for r in result]
            
            return jsonify({'success': True, 'contacts': contacts})
            
        except Exception as e:
            logger.error(f"API v1 list contacts error: {e}")
            return jsonify({'success': False, 'error': str(e)}), 500
    
    else:  # POST
        try:
            data = request.get_json()
            contact_id = str(uuid.uuid4())
            
            db.session.execute(
                text("""
                    INSERT INTO contacts (id, organization_id, email, name, created_at)
                    VALUES (:id, :org_id, :email, :name, NOW())
                """),
                {
                    'id': contact_id,
                    'org_id': request.org_id,
                    'email': data.get('email'),
                    'name': f"{data.get('first_name', '')} {data.get('last_name', '')}".strip()
                }
            )
            
            db.session.commit()
            
            return jsonify({'success': True, 'contact_id': contact_id})
            
        except Exception as e:
            db.session.rollback()
            logger.error(f"API v1 add contact error: {e}")
            return jsonify({'success': False, 'error': str(e)}), 500
