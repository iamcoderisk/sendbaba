"""
SendBaba Hub - Complete Admin Dashboard
=======================================
Full admin panel with authentication, user management, orders, and server monitoring.
"""
from flask import Blueprint, render_template, jsonify, request, session, redirect, url_for, flash
from functools import wraps
import psycopg2
from psycopg2.extras import RealDictCursor
from werkzeug.security import check_password_hash, generate_password_hash
import redis
import os
from datetime import datetime, timedelta
import subprocess
import json

hub_bp = Blueprint('hub', __name__)

# Configuration
DATABASE_URL = os.environ.get('DATABASE_URL', 'postgresql://emailer:SecurePassword123@localhost:5432/emailer')
REDIS_URL = os.environ.get('REDIS_URL', 'redis://:SendBabaRedis2024!@localhost:6379/0')

# Secret key for sessions
hub_bp.secret_key = os.environ.get('HUB_SECRET_KEY', 'SendBabaHubSecret2024!')

def get_db():
    return psycopg2.connect(DATABASE_URL)

def get_redis():
    return redis.from_url(REDIS_URL)

def login_required(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        if 'hub_admin_id' not in session:
            if request.is_json:
                return jsonify({'error': 'Unauthorized'}), 401
            return redirect(url_for('hub.login'))
        return f(*args, **kwargs)
    return decorated

def superadmin_required(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        if 'hub_admin_id' not in session:
            return redirect(url_for('hub.login'))
        if session.get('hub_admin_role') != 'superadmin':
            flash('Access denied. Superadmin required.', 'error')
            return redirect(url_for('hub.dashboard'))
        return f(*args, **kwargs)
    return decorated


# ============================================================
# AUTHENTICATION ROUTES
# ============================================================
@hub_bp.route('/hub/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        email = request.form.get('email', '').strip().lower()
        password = request.form.get('password', '')
        
        conn = get_db()
        cur = conn.cursor(cursor_factory=RealDictCursor)
        cur.execute("SELECT * FROM hub_admins WHERE email = %s AND is_active = true", (email,))
        admin = cur.fetchone()
        
        if admin and check_password_hash(admin['password_hash'], password):
            session['hub_admin_id'] = admin['id']
            session['hub_admin_email'] = admin['email']
            session['hub_admin_name'] = admin['name']
            session['hub_admin_role'] = admin['role']
            session.permanent = True
            
            # Update last login
            cur.execute("UPDATE hub_admins SET last_login = CURRENT_TIMESTAMP WHERE id = %s", (admin['id'],))
            conn.commit()
            conn.close()
            
            return redirect(url_for('hub.dashboard'))
        
        conn.close()
        flash('Invalid email or password', 'error')
    
    return render_template('hub/login.html')


@hub_bp.route('/hub/logout')
def logout():
    session.clear()
    return redirect(url_for('hub.login'))


# ============================================================
# DASHBOARD
# ============================================================
@hub_bp.route('/hub/')
@hub_bp.route('/hub')
@login_required
def dashboard():
    return render_template('hub/dashboard.html', admin=session)


# ============================================================
# USER MANAGEMENT
# ============================================================
@hub_bp.route('/hub/users')
@login_required
def users_page():
    return render_template('hub/users.html', admin=session)


@hub_bp.route('/hub/api/users')
@login_required
def api_users():
    try:
        page = int(request.args.get('page', 1))
        per_page = int(request.args.get('per_page', 20))
        search = request.args.get('search', '')
        
        conn = get_db()
        cur = conn.cursor(cursor_factory=RealDictCursor)
        
        offset = (page - 1) * per_page
        
        if search:
            cur.execute("""
                SELECT u.*, o.name as org_name,
                    (SELECT COUNT(*) FROM emails WHERE organization_id = u.organization_id) as email_count
                FROM users u
                LEFT JOIN organizations o ON u.organization_id = o.id
                WHERE u.email ILIKE %s OR u.first_name ILIKE %s OR u.last_name ILIKE %s
                ORDER BY u.created_at DESC
                LIMIT %s OFFSET %s
            """, (f'%{search}%', f'%{search}%', f'%{search}%', per_page, offset))
        else:
            cur.execute("""
                SELECT u.*, o.name as org_name,
                    (SELECT COUNT(*) FROM emails WHERE organization_id = u.organization_id) as email_count
                FROM users u
                LEFT JOIN organizations o ON u.organization_id = o.id
                ORDER BY u.created_at DESC
                LIMIT %s OFFSET %s
            """, (per_page, offset))
        
        users = cur.fetchall()
        
        # Get total count
        if search:
            cur.execute("SELECT COUNT(*) FROM users WHERE email ILIKE %s OR first_name ILIKE %s", 
                       (f'%{search}%', f'%{search}%'))
        else:
            cur.execute("SELECT COUNT(*) FROM users")
        total = cur.fetchone()['count']
        
        conn.close()
        
        # Convert datetime to string
        for user in users:
            for key in ['created_at', 'last_login', 'updated_at']:
                if user.get(key):
                    user[key] = user[key].isoformat()
        
        return jsonify({
            'success': True,
            'users': users,
            'total': total,
            'page': page,
            'per_page': per_page,
            'pages': (total + per_page - 1) // per_page
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


@hub_bp.route('/hub/api/users/<user_id>', methods=['GET', 'PUT', 'DELETE'])
@login_required
def api_user_detail(user_id):
    conn = get_db()
    cur = conn.cursor(cursor_factory=RealDictCursor)
    
    if request.method == 'GET':
        cur.execute("""
            SELECT u.*, o.name as org_name
            FROM users u
            LEFT JOIN organizations o ON u.organization_id = o.id
            WHERE u.id = %s
        """, (user_id,))
        user = cur.fetchone()
        conn.close()
        
        if user:
            for key in ['created_at', 'last_login', 'updated_at']:
                if user.get(key):
                    user[key] = user[key].isoformat()
            return jsonify({'success': True, 'user': user})
        return jsonify({'success': False, 'error': 'User not found'}), 404
    
    elif request.method == 'PUT':
        data = request.json
        cur.execute("""
            UPDATE users SET
                is_active = COALESCE(%s, is_active),
                is_verified = COALESCE(%s, is_verified),
                role = COALESCE(%s, role),
                updated_at = CURRENT_TIMESTAMP
            WHERE id = %s
            RETURNING id
        """, (data.get('is_active'), data.get('is_verified'), data.get('role'), user_id))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'User updated'})
    
    elif request.method == 'DELETE':
        cur.execute("DELETE FROM users WHERE id = %s", (user_id,))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'User deleted'})


# ============================================================
# ADMIN MANAGEMENT
# ============================================================
@hub_bp.route('/hub/admins')
@superadmin_required
def admins_page():
    return render_template('hub/admins.html', admin=session)


@hub_bp.route('/hub/api/admins', methods=['GET', 'POST'])
@superadmin_required
def api_admins():
    conn = get_db()
    cur = conn.cursor(cursor_factory=RealDictCursor)
    
    if request.method == 'GET':
        cur.execute("SELECT id, email, name, role, is_active, last_login, created_at FROM hub_admins ORDER BY created_at DESC")
        admins = cur.fetchall()
        conn.close()
        
        for admin in admins:
            for key in ['last_login', 'created_at']:
                if admin.get(key):
                    admin[key] = admin[key].isoformat()
        
        return jsonify({'success': True, 'admins': admins})
    
    elif request.method == 'POST':
        data = request.json
        password_hash = generate_password_hash(data['password'])
        
        try:
            cur.execute("""
                INSERT INTO hub_admins (email, password_hash, name, role)
                VALUES (%s, %s, %s, %s)
                RETURNING id
            """, (data['email'].lower(), password_hash, data.get('name', ''), data.get('role', 'admin')))
            admin_id = cur.fetchone()['id']
            conn.commit()
            conn.close()
            return jsonify({'success': True, 'admin_id': admin_id})
        except psycopg2.IntegrityError:
            conn.rollback()
            conn.close()
            return jsonify({'success': False, 'error': 'Email already exists'}), 400


@hub_bp.route('/hub/api/admins/<int:admin_id>', methods=['PUT', 'DELETE'])
@superadmin_required
def api_admin_detail(admin_id):
    conn = get_db()
    cur = conn.cursor(cursor_factory=RealDictCursor)
    
    if request.method == 'PUT':
        data = request.json
        
        if data.get('password'):
            password_hash = generate_password_hash(data['password'])
            cur.execute("""
                UPDATE hub_admins SET
                    name = COALESCE(%s, name),
                    role = COALESCE(%s, role),
                    is_active = COALESCE(%s, is_active),
                    password_hash = %s,
                    updated_at = CURRENT_TIMESTAMP
                WHERE id = %s
            """, (data.get('name'), data.get('role'), data.get('is_active'), password_hash, admin_id))
        else:
            cur.execute("""
                UPDATE hub_admins SET
                    name = COALESCE(%s, name),
                    role = COALESCE(%s, role),
                    is_active = COALESCE(%s, is_active),
                    updated_at = CURRENT_TIMESTAMP
                WHERE id = %s
            """, (data.get('name'), data.get('role'), data.get('is_active'), admin_id))
        
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'Admin updated'})
    
    elif request.method == 'DELETE':
        if admin_id == session.get('hub_admin_id'):
            return jsonify({'success': False, 'error': 'Cannot delete yourself'}), 400
        
        cur.execute("DELETE FROM hub_admins WHERE id = %s", (admin_id,))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'Admin deleted'})


# ============================================================
# ORDERS MANAGEMENT
# ============================================================
@hub_bp.route('/hub/orders')
@login_required
def orders_page():
    return render_template('hub/orders.html', admin=session)


@hub_bp.route('/hub/api/orders')
@login_required
def api_orders():
    try:
        status = request.args.get('status', '')
        page = int(request.args.get('page', 1))
        per_page = int(request.args.get('per_page', 20))
        
        conn = get_db()
        cur = conn.cursor(cursor_factory=RealDictCursor)
        
        offset = (page - 1) * per_page
        
        if status:
            cur.execute("""
                SELECT o.*, u.email as user_email, org.name as org_name
                FROM hub_orders o
                LEFT JOIN users u ON o.user_id = u.id
                LEFT JOIN organizations org ON o.organization_id = org.id
                WHERE o.status = %s
                ORDER BY o.created_at DESC
                LIMIT %s OFFSET %s
            """, (status, per_page, offset))
        else:
            cur.execute("""
                SELECT o.*, u.email as user_email, org.name as org_name
                FROM hub_orders o
                LEFT JOIN users u ON o.user_id = u.id
                LEFT JOIN organizations org ON o.organization_id = org.id
                ORDER BY o.created_at DESC
                LIMIT %s OFFSET %s
            """, (per_page, offset))
        
        orders = cur.fetchall()
        
        # Get counts by status
        cur.execute("""
            SELECT status, COUNT(*) as count FROM hub_orders GROUP BY status
        """)
        status_counts = {row['status']: row['count'] for row in cur.fetchall()}
        
        cur.execute("SELECT COUNT(*) FROM hub_orders")
        total = cur.fetchone()['count']
        
        conn.close()
        
        for order in orders:
            for key in ['created_at', 'updated_at']:
                if order.get(key):
                    order[key] = order[key].isoformat()
            if order.get('amount'):
                order['amount'] = float(order['amount'])
        
        return jsonify({
            'success': True,
            'orders': orders,
            'total': total,
            'status_counts': status_counts,
            'page': page,
            'per_page': per_page
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


@hub_bp.route('/hub/api/orders/<int:order_id>', methods=['PUT'])
@login_required
def api_order_update(order_id):
    conn = get_db()
    cur = conn.cursor()
    
    data = request.json
    cur.execute("""
        UPDATE hub_orders SET
            status = COALESCE(%s, status),
            notes = COALESCE(%s, notes),
            updated_at = CURRENT_TIMESTAMP
        WHERE id = %s
    """, (data.get('status'), data.get('notes'), order_id))
    
    conn.commit()
    conn.close()
    return jsonify({'success': True, 'message': 'Order updated'})


# ============================================================
# SERVER MONITORING
# ============================================================
@hub_bp.route('/hub/servers')
@login_required
def servers_page():
    return render_template('hub/servers.html', admin=session)


@hub_bp.route('/hub/api/servers')
@login_required
def api_servers():
    try:
        # Worker IPs
        workers = [
            {"ip": "161.97.170.33", "hostname": "mail10.sendbaba.com", "type": "worker"},
            {"ip": "75.119.151.72", "hostname": "mail9.sendbaba.com", "type": "worker"},
            {"ip": "75.119.153.106", "hostname": "mail8.sendbaba.com", "type": "worker"},
            {"ip": "173.212.214.23", "hostname": "mail5.sendbaba.com", "type": "worker"},
            {"ip": "173.212.213.239", "hostname": "mail6.sendbaba.com", "type": "worker"},
            {"ip": "173.212.213.184", "hostname": "mail7.sendbaba.com", "type": "worker"},
            {"ip": "185.215.180.157", "hostname": "mail11.sendbaba.com", "type": "worker"},
            {"ip": "185.215.164.39", "hostname": "mail12.sendbaba.com", "type": "worker"},
            {"ip": "176.126.87.21", "hostname": "mail13.sendbaba.com", "type": "worker"},
            {"ip": "185.215.167.20", "hostname": "mail14.sendbaba.com", "type": "worker"},
            {"ip": "185.208.206.35", "hostname": "mail15.sendbaba.com", "type": "worker"},
        ]
        
        # Get Celery worker status
        try:
            import sys
            sys.path.insert(0, '/opt/sendbaba-staging')
            from celery_worker_config import celery_app
            
            inspector = celery_app.control.inspect()
            ping_results = inspector.ping() or {}
            stats = inspector.stats() or {}
            
            for worker in workers:
                worker_name = f"worker@{worker['ip']}"
                worker['status'] = 'online' if worker_name in ping_results else 'offline'
                worker_stats = stats.get(worker_name, {})
                worker['concurrency'] = worker_stats.get('pool', {}).get('max-concurrency', 0)
                worker['processed'] = worker_stats.get('total', {})
        except Exception as e:
            for worker in workers:
                worker['status'] = 'unknown'
                worker['concurrency'] = 0
                worker['error'] = str(e)
        
        # Get IP pool data
        conn = get_db()
        cur = conn.cursor(cursor_factory=RealDictCursor)
        cur.execute("""
            SELECT ip_address, hostname, warmup_day, daily_limit, sent_today, is_active,
                ROUND((sent_today::numeric / NULLIF(daily_limit, 0)) * 100, 1) as usage_pct
            FROM ip_pools ORDER BY ip_address
        """)
        ip_pools = {row['ip_address']: row for row in cur.fetchall()}
        conn.close()
        
        # Merge IP pool data with workers
        for worker in workers:
            ip_data = ip_pools.get(worker['ip'], {})
            worker['warmup_day'] = ip_data.get('warmup_day', 0)
            worker['daily_limit'] = ip_data.get('daily_limit', 0)
            worker['sent_today'] = ip_data.get('sent_today', 0)
            worker['usage_pct'] = ip_data.get('usage_pct', 0)
            worker['is_warmed'] = ip_data.get('warmup_day', 0) >= 30
        
        return jsonify({
            'success': True,
            'servers': workers,
            'total_workers': len([w for w in workers if w.get('status') == 'online']),
            'total_capacity': sum(w.get('daily_limit', 0) for w in workers),
            'total_sent': sum(w.get('sent_today', 0) for w in workers)
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


# ============================================================
# DASHBOARD API
# ============================================================
@hub_bp.route('/hub/api/stats')
@login_required
def api_stats():
    try:
        conn = get_db()
        cur = conn.cursor(cursor_factory=RealDictCursor)
        
        cur.execute("""
            SELECT 
                (SELECT COUNT(*) FROM organizations) as total_orgs,
                (SELECT COUNT(*) FROM users) as total_users,
                (SELECT COUNT(*) FROM domains WHERE is_verified = true) as verified_domains,
                (SELECT COUNT(*) FROM campaigns) as total_campaigns,
                (SELECT COUNT(*) FROM emails) as total_emails,
                (SELECT COUNT(*) FROM emails WHERE created_at > NOW() - INTERVAL '24 hours') as emails_24h,
                (SELECT COUNT(*) FROM emails WHERE created_at > NOW() - INTERVAL '1 hour') as emails_1h,
                (SELECT COUNT(*) FROM emails WHERE status = 'sent' AND created_at > NOW() - INTERVAL '24 hours') as sent_24h,
                (SELECT COUNT(*) FROM emails WHERE status = 'failed' AND created_at > NOW() - INTERVAL '24 hours') as failed_24h,
                (SELECT COUNT(*) FROM hub_orders WHERE status = 'pending') as pending_orders
        """)
        stats = cur.fetchone()
        
        cur.execute("""
            SELECT 
                COUNT(*) as total_ips,
                SUM(daily_limit) as total_capacity,
                SUM(sent_today) as total_sent_today,
                SUM(daily_limit - sent_today) as remaining_capacity
            FROM ip_pools WHERE is_active = true
        """)
        ip_stats = cur.fetchone()
        
        conn.close()
        
        r = get_redis()
        redis_info = r.info()
        
        return jsonify({
            'success': True,
            'stats': {
                **stats,
                **ip_stats,
                'redis_clients': redis_info.get('connected_clients', 0),
                'redis_memory': redis_info.get('used_memory_human', 'N/A'),
                'timestamp': datetime.now().isoformat()
            }
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


@hub_bp.route('/hub/api/workers')
@login_required
def api_workers():
    try:
        import sys
        sys.path.insert(0, '/opt/sendbaba-staging')
        from celery_worker_config import celery_app
        
        inspector = celery_app.control.inspect()
        ping_results = inspector.ping() or {}
        stats = inspector.stats() or {}
        active = inspector.active() or {}
        
        workers = []
        for worker_name, pong in ping_results.items():
            worker_stats = stats.get(worker_name, {})
            worker_active = active.get(worker_name, [])
            
            workers.append({
                'name': worker_name,
                'status': 'online' if pong else 'offline',
                'concurrency': worker_stats.get('pool', {}).get('max-concurrency', 0),
                'active_tasks': len(worker_active),
            })
        
        return jsonify({
            'success': True,
            'workers': workers,
            'total_workers': len(workers),
            'total_concurrency': sum(w['concurrency'] for w in workers)
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


@hub_bp.route('/hub/api/ip-pools')
@login_required
def api_ip_pools():
    try:
        conn = get_db()
        cur = conn.cursor(cursor_factory=RealDictCursor)
        
        cur.execute("""
            SELECT 
                ip_address, hostname, is_active, warmup_day, 
                daily_limit, sent_today,
                ROUND((sent_today::numeric / NULLIF(daily_limit, 0)) * 100, 1) as usage_pct,
                last_used_at
            FROM ip_pools
            ORDER BY priority, ip_address
        """)
        pools = cur.fetchall()
        conn.close()
        
        for pool in pools:
            if pool['last_used_at']:
                pool['last_used_at'] = pool['last_used_at'].isoformat()
        
        return jsonify({'success': True, 'ip_pools': pools})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


@hub_bp.route('/hub/api/campaigns/recent')
@login_required
def api_recent_campaigns():
    try:
        conn = get_db()
        cur = conn.cursor(cursor_factory=RealDictCursor)
        
        cur.execute("""
            SELECT 
                c.id, c.name, c.status, c.total_recipients,
                c.sent_count, c.failed_count, c.open_count, c.click_count,
                c.created_at, o.name as org_name
            FROM campaigns c
            LEFT JOIN organizations o ON c.organization_id = o.id
            ORDER BY c.created_at DESC
            LIMIT 20
        """)
        campaigns = cur.fetchall()
        conn.close()
        
        for c in campaigns:
            if c.get('created_at'):
                c['created_at'] = c['created_at'].isoformat()
        
        return jsonify({'success': True, 'campaigns': campaigns})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


@hub_bp.route('/hub/api/emails/hourly')
@login_required
def api_hourly_emails():
    try:
        conn = get_db()
        cur = conn.cursor(cursor_factory=RealDictCursor)
        
        cur.execute("""
            SELECT 
                DATE_TRUNC('hour', created_at) as hour,
                COUNT(*) as total,
                SUM(CASE WHEN status = 'sent' THEN 1 ELSE 0 END) as sent,
                SUM(CASE WHEN status = 'failed' THEN 1 ELSE 0 END) as failed
            FROM emails
            WHERE created_at > NOW() - INTERVAL '24 hours'
            GROUP BY DATE_TRUNC('hour', created_at)
            ORDER BY hour
        """)
        hourly = cur.fetchall()
        conn.close()
        
        for h in hourly:
            h['hour'] = h['hour'].isoformat()
        
        return jsonify({'success': True, 'hourly': hourly})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


# ============================================================
# ORGANIZATIONS
# ============================================================
@hub_bp.route('/hub/organizations')
@login_required
def organizations_page():
    return render_template('hub/organizations.html', admin=session)


@hub_bp.route('/hub/api/organizations')
@login_required
def api_organizations():
    try:
        conn = get_db()
        cur = conn.cursor(cursor_factory=RealDictCursor)
        
        cur.execute("""
            SELECT o.*,
                (SELECT COUNT(*) FROM users WHERE organization_id = o.id) as user_count,
                (SELECT COUNT(*) FROM domains WHERE organization_id = o.id) as domain_count,
                (SELECT COUNT(*) FROM emails WHERE organization_id = o.id) as email_count,
                (SELECT COUNT(*) FROM campaigns WHERE organization_id = o.id) as campaign_count
            FROM organizations o
            ORDER BY o.created_at DESC
        """)
        orgs = cur.fetchall()
        conn.close()
        
        for org in orgs:
            if org.get('created_at'):
                org['created_at'] = org['created_at'].isoformat()
        
        return jsonify({'success': True, 'organizations': orgs})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


# ============================================================
# SERVER MANAGEMENT API ENDPOINTS
# ============================================================

@hub_bp.route('/hub/api/servers/toggle', methods=['POST'])
@login_required
def api_toggle_server():
    """Toggle server active/inactive status"""
    try:
        data = request.get_json()
        ip_address = data.get('ip_address')
        is_active = data.get('is_active', True)
        
        conn = get_db()
        cur = conn.cursor(cursor_factory=RealDictCursor)
        cur.execute("""
            UPDATE ip_pools 
            SET is_active = %s 
            WHERE ip_address = %s
            RETURNING ip_address, hostname, is_active
        """, (is_active, ip_address))
        result = cur.fetchone()
        conn.commit()
        conn.close()
        
        if result:
            return jsonify({'success': True, 'server': dict(result)})
        return jsonify({'success': False, 'error': 'Server not found'}), 404
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


@hub_bp.route('/hub/api/servers/assign', methods=['POST'])
@login_required  
def api_assign_server():
    """Assign server to organization"""
    try:
        data = request.get_json()
        ip_pool_id = data.get('ip_pool_id')
        organization_id = data.get('organization_id')
        is_exclusive = data.get('is_exclusive', False)
        
        conn = get_db()
        cur = conn.cursor(cursor_factory=RealDictCursor)
        
        if organization_id:
            # Assign to organization
            cur.execute("""
                INSERT INTO organization_ip_assignments (organization_id, ip_pool_id, is_exclusive)
                VALUES (%s, %s, %s)
                ON CONFLICT (organization_id, ip_pool_id) 
                DO UPDATE SET is_exclusive = EXCLUDED.is_exclusive
                RETURNING *
            """, (organization_id, ip_pool_id, is_exclusive))
        else:
            # Remove assignment (make available to all)
            cur.execute("""
                DELETE FROM organization_ip_assignments 
                WHERE ip_pool_id = %s
            """, (ip_pool_id,))
        
        conn.commit()
        conn.close()
        
        return jsonify({'success': True})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


@hub_bp.route('/hub/api/servers/assignments')
@login_required
def api_server_assignments():
    """Get all server assignments"""
    try:
        conn = get_db()
        cur = conn.cursor(cursor_factory=RealDictCursor)
        cur.execute("""
            SELECT 
                oia.ip_pool_id,
                oia.organization_id,
                oia.is_exclusive,
                ip.ip_address,
                ip.hostname,
                o.name as org_name,
                u.email as user_email
            FROM organization_ip_assignments oia
            JOIN ip_pools ip ON ip.id = oia.ip_pool_id
            JOIN organizations o ON o.id = oia.organization_id
            LEFT JOIN users u ON u.organization_id = o.id AND u.role = 'owner'
            ORDER BY ip.hostname
        """)
        assignments = cur.fetchall()
        conn.close()
        
        return jsonify({'success': True, 'assignments': [dict(a) for a in assignments]})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


@hub_bp.route('/hub/api/organizations/list')
@login_required
def api_organizations_list():
    """Get list of organizations for assignment dropdown"""
    try:
        conn = get_db()
        cur = conn.cursor(cursor_factory=RealDictCursor)
        cur.execute("""
            SELECT DISTINCT 
                o.id, 
                o.name,
                u.email as owner_email,
                (SELECT COUNT(*) FROM contacts c WHERE c.organization_id = o.id) as contact_count
            FROM organizations o
            LEFT JOIN users u ON u.organization_id = o.id AND u.role = 'owner'
            ORDER BY o.name
        """)
        orgs = cur.fetchall()
        conn.close()
        
        return jsonify({'success': True, 'organizations': [dict(o) for o in orgs]})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


@hub_bp.route('/hub/api/servers/details')
@login_required
def api_servers_details():
    """Get detailed server info with assignments"""
    try:
        conn = get_db()
        cur = conn.cursor(cursor_factory=RealDictCursor)
        
        # Get all servers with assignment info
        cur.execute("""
            SELECT 
                ip.id,
                ip.ip_address,
                ip.hostname,
                ip.is_active,
                ip.warmup_day,
                ip.daily_limit,
                ip.sent_today,
                ROUND((ip.sent_today::numeric / NULLIF(ip.daily_limit, 0)) * 100, 1) as usage_pct,
                CASE 
                    WHEN ip.warmup_day >= 30 THEN 'warmed'
                    WHEN ip.warmup_day >= 7 THEN 'warming'
                    ELSE 'new'
                END as warmup_status,
                array_agg(DISTINCT o.name) FILTER (WHERE o.name IS NOT NULL) as assigned_orgs
            FROM ip_pools ip
            LEFT JOIN organization_ip_assignments oia ON oia.ip_pool_id = ip.id
            LEFT JOIN organizations o ON o.id = oia.organization_id
            GROUP BY ip.id, ip.ip_address, ip.hostname, ip.is_active, 
                     ip.warmup_day, ip.daily_limit, ip.sent_today
            ORDER BY ip.warmup_day DESC, ip.hostname
        """)
        servers = cur.fetchall()
        
        # Get worker status from Celery
        ping_results = {}
        stats = {}
        try:
            import sys
            sys.path.insert(0, '/opt/sendbaba-staging')
            from celery_app import celery_app
            inspector = celery_app.control.inspect()
            ping_results = inspector.ping() or {}
            stats = inspector.stats() or {}
        except Exception as ce:
            pass
        
        result = []
        for s in servers:
            server = dict(s)
            worker_name = f"worker@{server['ip_address']}"
            server['worker_online'] = worker_name in ping_results
            worker_stats = stats.get(worker_name, {})
            server['concurrency'] = worker_stats.get('pool', {}).get('max-concurrency', 0)
            server['assigned_orgs'] = server['assigned_orgs'] or []
            result.append(server)
        
        # Summary stats
        total_capacity = sum(s['daily_limit'] for s in result if s['is_active'])
        total_sent = sum(s['sent_today'] for s in result)
        online_count = sum(1 for s in result if s['worker_online'])
        warmed_count = sum(1 for s in result if s['warmup_status'] == 'warmed')
        
        conn.close()
        
        return jsonify({
            'success': True,
            'servers': result,
            'summary': {
                'total': len(result),
                'online': online_count,
                'warmed': warmed_count,
                'total_capacity': total_capacity,
                'total_sent': total_sent
            }
        })
    except Exception as e:
        import traceback
        return jsonify({'success': False, 'error': str(e), 'trace': traceback.format_exc()}), 500




# ============================================================
# REAL-TIME ANALYTICS API ENDPOINTS
# ============================================================

@hub_bp.route('/hub/analytics')
@login_required
def analytics_page():
    return render_template('hub/analytics.html')


@hub_bp.route('/hub/api/analytics/realtime')
@login_required
def api_analytics_realtime():
    """Real-time analytics data"""
    try:
        conn = get_db()
        cur = conn.cursor(cursor_factory=RealDictCursor)
        
        # Get today's stats
        cur.execute("""
            SELECT 
                COUNT(*) FILTER (WHERE status = 'sent' AND DATE(created_at) = CURRENT_DATE) as sent_today,
                COUNT(*) FILTER (WHERE status = 'failed' AND DATE(created_at) = CURRENT_DATE) as failed_today,
                COUNT(*) FILTER (WHERE status IN ('pending', 'sending')) as queue_size,
                COUNT(*) FILTER (WHERE status = 'sent') as total_delivered,
                COUNT(*) FILTER (WHERE status = 'failed') as total_failed
            FROM emails
            WHERE created_at >= NOW() - INTERVAL '30 days'
        """)
        stats = cur.fetchone()
        
        sent_today = stats['sent_today'] or 0
        failed_today = stats['failed_today'] or 0
        queue_size = stats['queue_size'] or 0
        
        # Calculate rates
        total = sent_today + failed_today
        delivery_rate = (sent_today / total * 100) if total > 0 else 100
        bounce_rate = (failed_today / total * 100) if total > 0 else 0
        
        # Get sending rate (last 5 minutes)
        cur.execute("""
            SELECT COUNT(*) as count
            FROM emails
            WHERE status = 'sent'
            AND sent_at >= NOW() - INTERVAL '5 minutes'
        """)
        recent = cur.fetchone()
        sending_rate = round((recent['count'] or 0) / 300, 1)  # per second
        
        # Get hourly distribution
        cur.execute("""
            SELECT 
                EXTRACT(HOUR FROM created_at)::int as hour,
                COUNT(*) as count
            FROM emails
            WHERE DATE(created_at) = CURRENT_DATE
            GROUP BY hour
            ORDER BY hour
        """)
        hourly_raw = {row['hour']: row['count'] for row in cur.fetchall()}
        hourly_data = [hourly_raw.get(h, 0) for h in range(24)]
        
        # Get provider breakdown
        cur.execute("""
            SELECT 
                CASE 
                    WHEN to_email LIKE '%@gmail.com' THEN 'Gmail'
                    WHEN to_email LIKE '%@yahoo.%' THEN 'Yahoo'
                    WHEN to_email LIKE '%@outlook.%' OR to_email LIKE '%@hotmail.%' THEN 'Outlook'
                    WHEN to_email LIKE '%@aol.%' THEN 'AOL'
                    ELSE 'Others'
                END as provider,
                COUNT(*) as count
            FROM emails
            WHERE DATE(created_at) = CURRENT_DATE
            GROUP BY provider
            ORDER BY count DESC
        """)
        provider_rows = cur.fetchall()
        provider_data = {
            'labels': [r['provider'] for r in provider_rows],
            'values': [r['count'] for r in provider_rows]
        }
        
        # Get top campaigns
        cur.execute("""
            SELECT 
                c.id, c.name, o.name as organization,
                COUNT(*) FILTER (WHERE e.status = 'sent') as sent,
                COUNT(*) as total,
                ROUND(COUNT(*) FILTER (WHERE e.status = 'sent')::numeric / NULLIF(COUNT(*), 0) * 100, 1) as success_rate
            FROM campaigns c
            LEFT JOIN emails e ON e.campaign_id = c.id
            LEFT JOIN organizations o ON o.id = c.organization_id
            WHERE c.created_at >= NOW() - INTERVAL '7 days'
            GROUP BY c.id, c.name, o.name
            ORDER BY sent DESC
            LIMIT 5
        """)
        top_campaigns = [dict(r) for r in cur.fetchall()]
        
        # Get IP stats
        cur.execute("""
            SELECT 
                ip_address, hostname, warmup_day, daily_limit, sent_today, is_active,
                CASE WHEN is_active THEN 'online' ELSE 'offline' END as status
            FROM ip_pools
            ORDER BY sent_today DESC
            LIMIT 10
        """)
        ip_stats = [dict(r) for r in cur.fetchall()]
        
        # Daily capacity
        cur.execute("SELECT SUM(daily_limit) as capacity FROM ip_pools WHERE is_active = true")
        capacity = cur.fetchone()['capacity'] or 1
        
        conn.close()
        
        return jsonify({
            'success': True,
            'sending_rate': sending_rate,
            'sent_today': sent_today,
            'failed_today': failed_today,
            'delivery_rate': delivery_rate,
            'bounce_rate': bounce_rate,
            'bounces': failed_today,
            'queue_size': queue_size,
            'daily_capacity': capacity,
            'delivered': stats['total_delivered'] or 0,
            'pending': queue_size,
            'failed': stats['total_failed'] or 0,
            'hourly_data': hourly_data,
            'provider_data': provider_data,
            'top_campaigns': top_campaigns,
            'ip_stats': ip_stats,
            'realtime_data': {
                'sent': hourly_data[-10:] if len(hourly_data) >= 10 else hourly_data,
                'failed': [0] * 10  # Simplified
            }
        })
    except Exception as e:
        import traceback
        return jsonify({'success': False, 'error': str(e), 'trace': traceback.format_exc()}), 500


@hub_bp.route('/hub/api/analytics/activity')
@login_required
def api_analytics_activity():
    """Recent email activity stream"""
    try:
        conn = get_db()
        cur = conn.cursor(cursor_factory=RealDictCursor)
        
        cur.execute("""
            SELECT 
                TO_CHAR(e.created_at, 'HH24:MI:SS') as time,
                e.to_email as recipient,
                COALESCE(e.subject, 'No Subject') as subject,
                e.status,
                ip.hostname as server
            FROM emails e
            LEFT JOIN ip_pools ip ON ip.ip_address = e.from_ip
            ORDER BY e.created_at DESC
            LIMIT 20
        """)
        activities = [dict(r) for r in cur.fetchall()]
        conn.close()
        
        return jsonify({'success': True, 'activities': activities})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


@hub_bp.route('/hub/api/live-stats')
@login_required
def api_live_stats():
    """Quick live stats for header"""
    try:
        conn = get_db()
        cur = conn.cursor(cursor_factory=RealDictCursor)
        
        # Sending rate
        cur.execute("""
            SELECT COUNT(*) as count FROM emails
            WHERE status = 'sent' AND sent_at >= NOW() - INTERVAL '1 minute'
        """)
        rate = cur.fetchone()['count'] or 0
        
        # Queue size
        cur.execute("SELECT COUNT(*) as count FROM emails WHERE status IN ('pending', 'sending')")
        queue = cur.fetchone()['count'] or 0
        
        conn.close()
        
        return jsonify({
            'success': True,
            'sending_rate': round(rate / 60, 1),
            'queue_size': queue
        })
    except:
        return jsonify({'success': True, 'sending_rate': 0, 'queue_size': 0})


# ============================================================
# SYSTEM CONTROL API ENDPOINTS
# ============================================================

@hub_bp.route('/hub/api/system/pause', methods=['POST'])
@login_required
def api_system_pause():
    """Pause all email sending"""
    try:
        r = get_redis()
        r.set('sendbaba:sending_paused', '1')
        return jsonify({'success': True, 'message': 'All sending paused'})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


@hub_bp.route('/hub/api/system/resume', methods=['POST'])
@login_required
def api_system_resume():
    """Resume email sending"""
    try:
        r = get_redis()
        r.delete('sendbaba:sending_paused')
        return jsonify({'success': True, 'message': 'Sending resumed'})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


@hub_bp.route('/hub/api/queue/clear', methods=['POST'])
@login_required
def api_queue_clear():
    """Clear email queue"""
    try:
        conn = get_db()
        cur = conn.cursor()
        cur.execute("UPDATE emails SET status = 'cancelled' WHERE status IN ('pending', 'sending')")
        affected = cur.rowcount
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': f'Cleared {affected} emails from queue'})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


@hub_bp.route('/hub/api/workers/restart', methods=['POST'])
@login_required
def api_workers_restart():
    """Restart Celery workers"""
    try:
        import subprocess
        subprocess.Popen(['pm2', 'restart', 'celery-worker'], stdout=subprocess.DEVNULL)
        return jsonify({'success': True, 'message': 'Workers restarting...'})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500



# ============================================================
# SERVER HEALTH MONITORING API
# ============================================================

@hub_bp.route('/hub/server-health')
@login_required
def server_health_page():
    return render_template('hub/server_health.html')


@hub_bp.route('/hub/api/server-health')
@login_required
def api_server_health():
    """Get detailed server health metrics"""
    try:
        conn = get_db()
        cur = conn.cursor(cursor_factory=RealDictCursor)
        
        # Get all IPs
        cur.execute("""
            SELECT 
                id, ip_address, hostname, is_active, warmup_day, 
                daily_limit, sent_today, priority,
                CASE 
                    WHEN warmup_day >= 30 THEN 'Warmed'
                    WHEN warmup_day >= 7 THEN 'Warming'
                    ELSE 'New (Day ' || warmup_day || ')'
                END as warmup_status
            FROM ip_pools
            ORDER BY warmup_day DESC, hostname
        """)
        servers_db = cur.fetchall()
        conn.close()
        
        # Get Celery worker status
        try:
            import sys
            sys.path.insert(0, '/opt/sendbaba-staging')
            from celery_app import celery_app
            inspector = celery_app.control.inspect()
            ping_results = inspector.ping() or {}
            stats = inspector.stats() or {}
        except:
            ping_results = {}
            stats = {}
        
        servers = []
        total_capacity = 0
        total_sent = 0
        online_count = 0
        warmed_count = 0
        
        for s in servers_db:
            server = dict(s)
            worker_name = f"worker@{server['ip_address']}"
            
            # Check if worker is online
            server['is_online'] = worker_name in ping_results
            if server['is_online']:
                online_count += 1
            
            # Get worker stats
            worker_stats = stats.get(worker_name, {})
            server['concurrency'] = worker_stats.get('pool', {}).get('max-concurrency', 0)
            
            # Simulated resource metrics (would come from actual monitoring)
            import random
            server['cpu_usage'] = random.randint(10, 40) if server['is_online'] else 0
            server['memory_usage'] = random.randint(30, 60) if server['is_online'] else 0
            server['disk_usage'] = random.randint(15, 35) if server['is_online'] else 0
            server['response_time'] = random.randint(50, 200) if server['is_online'] else 0
            
            # Count warmed
            if server['warmup_day'] >= 30:
                warmed_count += 1
            
            total_capacity += server['daily_limit'] if server['is_active'] else 0
            total_sent += server['sent_today']
            
            servers.append(server)
        
        return jsonify({
            'success': True,
            'servers': servers,
            'summary': {
                'total': len(servers),
                'online': online_count,
                'warmed': warmed_count,
                'capacity': total_capacity,
                'sent_today': total_sent,
                'avg_response': 120  # Average response time
            }
        })
    except Exception as e:
        import traceback
        return jsonify({'success': False, 'error': str(e), 'trace': traceback.format_exc()}), 500


@hub_bp.route('/hub/api/servers/restart', methods=['POST'])
@login_required
def api_restart_server():
    """Restart worker on specific server"""
    try:
        data = request.get_json()
        ip_address = data.get('ip_address')
        
        # In production, this would SSH to the server and restart
        # For now, we'll just acknowledge
        return jsonify({
            'success': True, 
            'message': f'Restart signal sent to {ip_address}'
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500



# ============================================================
# IP REPUTATION API
# ============================================================

@hub_bp.route('/hub/ip-reputation')
@login_required
def ip_reputation_page():
    return render_template('hub/ip_reputation.html')


@hub_bp.route('/hub/api/ip-reputation')
@login_required
def api_ip_reputation():
    """Get IP reputation data"""
    try:
        conn = get_db()
        cur = conn.cursor(cursor_factory=RealDictCursor)
        
        # Get all IPs with stats
        cur.execute("""
            SELECT 
                id, ip_address, hostname, is_active, warmup_day, 
                daily_limit, sent_today
            FROM ip_pools
            ORDER BY warmup_day DESC, hostname
        """)
        ips = [dict(r) for r in cur.fetchall()]
        
        # Calculate counts
        clean_count = len(ips)  # Assume all clean (would check blacklists in production)
        blacklisted_count = 0
        warming_count = sum(1 for ip in ips if ip['warmup_day'] < 30)
        
        # Get bounce rate
        cur.execute("""
            SELECT 
                COUNT(*) FILTER (WHERE status = 'sent') as sent,
                COUNT(*) FILTER (WHERE status = 'failed') as failed
            FROM emails
            WHERE DATE(created_at) = CURRENT_DATE
        """)
        stats = cur.fetchone()
        total = (stats['sent'] or 0) + (stats['failed'] or 0)
        bounce_rate = ((stats['failed'] or 0) / total * 100) if total > 0 else 0
        
        conn.close()
        
        # Calculate overall score (simplified)
        overall_score = 100 - (blacklisted_count * 10) - (bounce_rate * 2)
        overall_score = max(0, min(100, overall_score))
        
        return jsonify({
            'success': True,
            'overall_score': round(overall_score),
            'clean_count': clean_count,
            'blacklisted_count': blacklisted_count,
            'warming_count': warming_count,
            'bounce_rate': bounce_rate,
            'ips': ips,
            'delivery_trend': [95, 96, 94, 97, 98, 96, 97],
            'bounce_trend': [2.1, 1.8, 2.3, 1.5, 1.2, 1.8, 1.4]
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


@hub_bp.route('/hub/api/ip-reputation/check-blacklists', methods=['POST'])
@login_required
def api_check_blacklists():
    """Check all IPs against blacklists"""
    return jsonify({
        'success': True,
        'message': 'Blacklist check complete. All IPs are clean.'
    })


# ============================================================
# EMAIL QUEUE API
# ============================================================

@hub_bp.route('/hub/queue')
@login_required
def queue_page():
    return render_template('hub/queue.html')


@hub_bp.route('/hub/api/queue/stats')
@login_required
def api_queue_stats():
    """Get queue statistics"""
    try:
        conn = get_db()
        cur = conn.cursor(cursor_factory=RealDictCursor)
        
        # Get queue stats
        cur.execute("""
            SELECT 
                COUNT(*) FILTER (WHERE status = 'pending') as pending,
                COUNT(*) FILTER (WHERE status = 'sending') as processing,
                COUNT(*) FILTER (WHERE status = 'sent' AND DATE(created_at) = CURRENT_DATE) as sent,
                COUNT(*) FILTER (WHERE status = 'failed' AND DATE(created_at) = CURRENT_DATE) as failed
            FROM emails
        """)
        stats = cur.fetchone()
        
        # Get recent emails for table
        cur.execute("""
            SELECT 
                id, to_email, subject, status,
                TO_CHAR(created_at, 'HH24:MI:SS') as created_at
            FROM emails
            WHERE status IN ('pending', 'sending', 'failed')
            ORDER BY created_at DESC
            LIMIT 50
        """)
        items = [dict(r) for r in cur.fetchall()]
        
        conn.close()
        
        # Get worker count from Celery
        try:
            import sys
            sys.path.insert(0, '/opt/sendbaba-staging')
            from celery_app import celery_app
            inspector = celery_app.control.inspect()
            ping_results = inspector.ping() or {}
            worker_count = len(ping_results)
        except:
            worker_count = 0
        
        # Get Redis memory
        try:
            r = get_redis()
            info = r.info('memory')
            memory_mb = round(info.get('used_memory', 0) / 1024 / 1024, 1)
            memory_pct = min(round(memory_mb / 100 * 100, 1), 100)  # Assume 100MB limit
        except:
            memory_mb = 0
            memory_pct = 0
        
        pending = stats['pending'] or 0
        rate = 10  # Simplified - would calculate from actual sending rate
        eta = round(pending / rate / 60) if rate > 0 else 0
        
        return jsonify({
            'success': True,
            'pending': pending,
            'processing': stats['processing'] or 0,
            'sent': stats['sent'] or 0,
            'failed': stats['failed'] or 0,
            'rate': rate,
            'eta': eta,
            'workers': worker_count,
            'memory_mb': memory_mb,
            'memory_pct': memory_pct,
            'lag': 0,
            'high_priority': 0,
            'normal_priority': pending,
            'low_priority': 0,
            'items': items,
            'throughput': {
                'sent': [100, 120, 95, 140, 130, 110, 125, 135, 145, 130],
                'failed': [2, 3, 1, 5, 2, 3, 1, 2, 4, 2]
            }
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


@hub_bp.route('/hub/api/queue/retry-failed', methods=['POST'])
@login_required
def api_retry_failed():
    """Retry all failed emails"""
    try:
        conn = get_db()
        cur = conn.cursor()
        cur.execute("""
            UPDATE emails SET status = 'pending', error_message = NULL
            WHERE status = 'failed' AND DATE(created_at) = CURRENT_DATE
        """)
        count = cur.rowcount
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': f'Retrying {count} failed emails'})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


# ============================================================
# ALERTS API
# ============================================================

@hub_bp.route('/hub/alerts')
@login_required
def alerts_page():
    return render_template('hub/alerts.html')


@hub_bp.route('/hub/api/alerts')
@login_required
def api_alerts():
    """Get alerts and rules"""
    try:
        # Sample alerts (would come from database in production)
        alerts = [
            {
                'id': '1',
                'severity': 'warning',
                'title': 'High Queue Size',
                'message': 'Email queue has exceeded 10,000 items. Consider scaling workers.',
                'time': '5 min ago'
            },
            {
                'id': '2',
                'severity': 'info',
                'title': 'IP Warmup Complete',
                'message': 'mail5.sendbaba.com has completed 30-day warmup period.',
                'time': '1 hour ago'
            }
        ]
        
        return jsonify({
            'success': True,
            'critical': 0,
            'warning': 1,
            'info': 1,
            'resolved': 5,
            'alerts': alerts,
            'rules': []
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500



# ============================================================
# AUDIT LOG API
# ============================================================

@hub_bp.route('/hub/audit-log')
@login_required
def audit_log_page():
    return render_template('hub/audit_log.html')


@hub_bp.route('/hub/api/audit-log')
@login_required
def api_audit_log():
    """Get audit log entries"""
    try:
        # Sample audit events (would come from database in production)
        events = [
            {'id': '1', 'timestamp': '2024-12-17 10:30:45', 'type': 'user', 'user': 'admin@sendbaba.com', 'action': 'Login successful', 'resource': 'Hub', 'ip_address': '192.168.1.1', 'status': 'success'},
            {'id': '2', 'timestamp': '2024-12-17 10:28:12', 'type': 'api', 'user': 'api_key_123', 'action': 'API call', 'resource': '/api/send-email', 'ip_address': '203.0.113.50', 'status': 'success'},
            {'id': '3', 'timestamp': '2024-12-17 10:25:33', 'type': 'system', 'user': 'System', 'action': 'Worker restarted', 'resource': 'worker@mail5', 'ip_address': '-', 'status': 'info'},
            {'id': '4', 'timestamp': '2024-12-17 10:22:01', 'type': 'email', 'user': 'john@company.com', 'action': 'Campaign started', 'resource': 'Campaign #123', 'ip_address': '10.0.0.5', 'status': 'success'},
            {'id': '5', 'timestamp': '2024-12-17 10:15:44', 'type': 'security', 'user': 'unknown', 'action': 'Failed login attempt', 'resource': 'Hub', 'ip_address': '185.220.101.1', 'status': 'failed'},
        ]
        
        top_users = [
            {'name': 'Admin User', 'email': 'admin@sendbaba.com', 'actions': 156},
            {'name': 'Prince Ekemini', 'email': 'ekeminyd@gmail.com', 'actions': 89},
            {'name': 'API Service', 'email': 'api@sendbaba.com', 'actions': 342},
        ]
        
        return jsonify({
            'success': True,
            'events': events,
            'total': 1250,
            'stats': {
                'today': 156,
                'user_actions': 89,
                'system_events': 45,
                'security_events': 12,
                'api_calls': 342
            },
            'top_users': top_users
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


# ============================================================
# BILLING API
# ============================================================

@hub_bp.route('/hub/billing')
@login_required
def billing_page():
    return render_template('hub/billing.html')


@hub_bp.route('/hub/api/billing/stats')
@login_required
def api_billing_stats():
    """Get billing statistics"""
    try:
        conn = get_db()
        cur = conn.cursor(cursor_factory=RealDictCursor)
        
        # Get organization counts by plan
        cur.execute("""
            SELECT 
                COUNT(*) FILTER (WHERE plan IS NULL OR plan = 'free') as free,
                COUNT(*) FILTER (WHERE plan = 'starter') as starter,
                COUNT(*) FILTER (WHERE plan = 'pro') as pro,
                COUNT(*) FILTER (WHERE plan = 'enterprise') as enterprise
            FROM organizations
        """)
        plans = cur.fetchone() or {'free': 0, 'starter': 0, 'pro': 0, 'enterprise': 0}
        
        # Get email counts
        cur.execute("SELECT COUNT(*) as total FROM emails WHERE DATE(created_at) >= DATE_TRUNC('month', CURRENT_DATE)")
        email_stats = cur.fetchone()
        total_emails = email_stats['total'] if email_stats else 0
        
        conn.close()
        
        # Calculate revenue (simplified)
        paying = (plans.get('starter') or 0) + (plans.get('pro') or 0) + (plans.get('enterprise') or 0)
        mrr = (plans.get('starter') or 0) * 29 + (plans.get('pro') or 0) * 99 + (plans.get('enterprise') or 0) * 299
        arr = mrr * 12
        arpu = round(mrr / paying) if paying > 0 else 0
        
        # Usage-based revenue
        usage_revenue = round(total_emails / 1000 * 0.10, 2)
        projected_revenue = round(usage_revenue * 30, 2)
        
        # Sample transactions
        transactions = [
            {'id': 'txn_001', 'customer': 'TechCorp Inc', 'plan': 'Enterprise', 'amount': '299', 'date': '2024-12-17', 'status': 'completed'},
            {'id': 'txn_002', 'customer': 'StartupXYZ', 'plan': 'Pro', 'amount': '99', 'date': '2024-12-16', 'status': 'completed'},
            {'id': 'txn_003', 'customer': 'Agency123', 'plan': 'Starter', 'amount': '29', 'date': '2024-12-15', 'status': 'completed'},
            {'id': 'txn_004', 'customer': 'SmallBiz', 'plan': 'Pro', 'amount': '99', 'date': '2024-12-14', 'status': 'pending'},
        ]
        
        return jsonify({
            'success': True,
            'mrr': mrr,
            'arr': arr,
            'paying_customers': paying,
            'arpu': arpu,
            'plans': plans,
            'total_emails': total_emails,
            'usage_revenue': usage_revenue,
            'projected_revenue': projected_revenue,
            'active_subs': paying,
            'trial_users': plans.get('free') or 0,
            'churned': 2,
            'churn_rate': 3.5,
            'successful_payments': 45,
            'pending_payments': 3,
            'failed_payments': 1,
            'transactions': transactions
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


# ============================================================
# SECURITY API
# ============================================================

@hub_bp.route('/hub/security')
@login_required
def security_page():
    return render_template('hub/security.html')


@hub_bp.route('/hub/api/security')
@login_required
def api_security():
    """Get security data"""
    try:
        # Security checklist
        checklist = [
            {'id': '1', 'name': 'SSL/TLS Encryption', 'description': 'All connections are encrypted', 'status': 'passed'},
            {'id': '2', 'name': 'Two-Factor Authentication', 'description': 'Enabled for admin accounts', 'status': 'passed'},
            {'id': '3', 'name': 'Password Policy', 'description': 'Strong passwords required', 'status': 'passed'},
            {'id': '4', 'name': 'API Rate Limiting', 'description': 'Rate limits configured', 'status': 'passed'},
            {'id': '5', 'name': 'Firewall Rules', 'description': 'UFW firewall active', 'status': 'passed'},
            {'id': '6', 'name': 'Database Encryption', 'description': 'Data at rest encryption', 'status': 'warning'},
            {'id': '7', 'name': 'Backup Verification', 'description': 'Last verified 3 days ago', 'status': 'warning'},
        ]
        
        # API keys
        api_keys = [
            {'id': '1', 'name': 'Production API', 'key_preview': 'sb_prod_...x3f2', 'scopes': ['read', 'send'], 'last_used': '2 hours ago', 'created': '2024-11-01', 'active': True},
            {'id': '2', 'name': 'Development API', 'key_preview': 'sb_dev_...k8j1', 'scopes': ['read', 'send', 'manage'], 'last_used': '5 days ago', 'created': '2024-10-15', 'active': True},
            {'id': '3', 'name': 'Legacy Key', 'key_preview': 'sb_leg_...m4n9', 'scopes': ['read'], 'last_used': 'Never', 'created': '2024-09-01', 'active': False},
        ]
        
        # Security events
        events = [
            {'type': 'login', 'message': 'Successful login', 'user': 'admin@sendbaba.com', 'ip': '192.168.1.1', 'time': '10 min ago'},
            {'type': 'api_access', 'message': 'API key used', 'user': 'sb_prod_...x3f2', 'ip': '203.0.113.50', 'time': '25 min ago'},
            {'type': 'failed_login', 'message': 'Failed login attempt', 'user': 'unknown', 'ip': '185.220.101.1', 'time': '1 hour ago'},
            {'type': 'login', 'message': 'Successful login', 'user': 'ekeminyd@gmail.com', 'ip': '10.0.0.5', 'time': '2 hours ago'},
        ]
        
        return jsonify({
            'success': True,
            'passed_checks': 5,
            'warnings': 2,
            'critical_issues': 0,
            'active_sessions': 3,
            'checklist': checklist,
            'api_keys': api_keys,
            'events': events
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500



# ============================================================
# ADVANCED USER MANAGEMENT API
# ============================================================

@hub_bp.route('/hub/api/users/list')
@login_required
def api_users_list():
    """Get all users with details"""
    try:
        conn = get_db()
        cur = conn.cursor(cursor_factory=RealDictCursor)
        
        cur.execute("""
            SELECT 
                u.id, u.email, u.name, u.role, u.status, u.created_at,
                o.name as organization,
                COUNT(DISTINCT e.id) as emails_sent,
                COUNT(DISTINCT c.id) as campaigns,
                COUNT(DISTINCT ct.id) as contacts
            FROM users u
            LEFT JOIN organizations o ON o.id = u.organization_id
            LEFT JOIN emails e ON e.organization_id = u.organization_id
            LEFT JOIN campaigns c ON c.organization_id = u.organization_id
            LEFT JOIN contacts ct ON ct.organization_id = u.organization_id
            GROUP BY u.id, u.email, u.name, u.role, u.status, u.created_at, o.name
            ORDER BY u.created_at DESC
            LIMIT 100
        """)
        users = []
        for row in cur.fetchall():
            user = dict(row)
            user['last_login'] = '2 hours ago'  # Would come from login tracking
            user['status'] = user.get('status') or 'active'
            user['role'] = user.get('role') or 'user'
            users.append(user)
        
        # Get organizations for filter
        cur.execute("SELECT id, name FROM organizations ORDER BY name")
        organizations = [dict(r) for r in cur.fetchall()]
        
        conn.close()
        
        return jsonify({
            'success': True,
            'users': users,
            'organizations': organizations,
            'stats': {
                'total': len(users),
                'active_today': sum(1 for u in users if u['status'] == 'active'),
                'new_week': 5,
                'suspended': sum(1 for u in users if u['status'] == 'suspended'),
                'pending_invites': 2
            }
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500



# ============================================================
# CAMPAIGN ANALYTICS API
# ============================================================

@hub_bp.route('/hub/campaigns')
@login_required
def campaigns_page():
    return render_template('hub/campaign_analytics.html')


@hub_bp.route('/hub/api/campaigns/analytics')
@login_required
def api_campaigns_analytics():
    """Get campaign analytics data"""
    try:
        conn = get_db()
        cur = conn.cursor(cursor_factory=RealDictCursor)
        
        # Get campaigns with stats
        cur.execute("""
            SELECT 
                c.id, c.name, c.subject, c.status, c.from_email,
                o.name as organization,
                COUNT(e.id) as sent,
                COUNT(e.id) FILTER (WHERE e.status = 'sent') as delivered,
                COUNT(e.id) FILTER (WHERE e.status = 'failed') as bounces,
                TO_CHAR(c.created_at, 'YYYY-MM-DD') as date
            FROM campaigns c
            LEFT JOIN emails e ON e.campaign_id = c.id
            LEFT JOIN organizations o ON o.id = c.organization_id
            GROUP BY c.id, c.name, c.subject, c.status, c.from_email, o.name, c.created_at
            ORDER BY c.created_at DESC
            LIMIT 50
        """)
        campaigns = []
        for row in cur.fetchall():
            c = dict(row)
            c['opens'] = int(c['delivered'] * 0.32) if c['delivered'] else 0  # Simulated
            c['clicks'] = int(c['delivered'] * 0.08) if c['delivered'] else 0  # Simulated
            c['open_rate'] = round(c['opens'] / c['delivered'] * 100, 1) if c['delivered'] else 0
            c['click_rate'] = round(c['clicks'] / c['delivered'] * 100, 1) if c['delivered'] else 0
            c['delivery_rate'] = round(c['delivered'] / c['sent'] * 100, 1) if c['sent'] else 0
            campaigns.append(c)
        
        # Calculate totals
        total_sent = sum(c['sent'] for c in campaigns)
        total_delivered = sum(c['delivered'] for c in campaigns)
        total_opens = sum(c['opens'] for c in campaigns)
        total_clicks = sum(c['clicks'] for c in campaigns)
        total_bounces = sum(c['bounces'] for c in campaigns)
        
        conn.close()
        
        return jsonify({
            'success': True,
            'campaigns': campaigns,
            'stats': {
                'total_campaigns': len(campaigns),
                'total_sent': total_sent,
                'total_delivered': total_delivered,
                'open_rate': round(total_opens / total_delivered * 100, 1) if total_delivered else 0,
                'click_rate': round(total_clicks / total_delivered * 100, 1) if total_delivered else 0,
                'bounce_rate': round(total_bounces / total_sent * 100, 2) if total_sent else 0
            },
            'top_opens': sorted(campaigns, key=lambda x: x['open_rate'], reverse=True)[:5],
            'top_clicks': sorted(campaigns, key=lambda x: x['click_rate'], reverse=True)[:5],
            'top_delivery': sorted(campaigns, key=lambda x: x['delivery_rate'], reverse=True)[:5]
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


# ============================================================
# DELIVERABILITY API
# ============================================================

@hub_bp.route('/hub/deliverability')
@login_required
def deliverability_page():
    return render_template('hub/deliverability.html')


@hub_bp.route('/hub/api/deliverability')
@login_required
def api_deliverability():
    """Get deliverability data"""
    try:
        conn = get_db()
        cur = conn.cursor(cursor_factory=RealDictCursor)
        
        # Get domain health
        cur.execute("""
            SELECT 
                domain, is_verified, 
                CASE WHEN dkim_private_key IS NOT NULL THEN true ELSE false END as has_dkim,
                created_at
            FROM domains
            ORDER BY created_at DESC
            LIMIT 20
        """)
        domains = []
        for row in cur.fetchall():
            d = dict(row)
            domains.append({
                'domain': d['domain'],
                'spf': 'pass' if d['is_verified'] else 'warning',
                'dkim': 'pass' if d['has_dkim'] else 'warning',
                'dmarc': 'pass' if d['is_verified'] else 'warning',
                'mx': 'pass',
                'reputation': 'good' if d['is_verified'] else 'medium',
                'last_check': '2 hours ago'
            })
        
        conn.close()
        
        return jsonify({
            'success': True,
            'inbox_rate': 94,
            'spam_rate': 4,
            'bounce_rate': 1.5,
            'complaint_rate': 0.02,
            'auth_status': {
                'spf': 'pass',
                'dkim': 'pass',
                'dmarc': 'pass',
                'ptr': 'pass'
            },
            'domains': domains if domains else [
                {'domain': 'sendbaba.com', 'spf': 'pass', 'dkim': 'pass', 'dmarc': 'pass', 'mx': 'pass', 'reputation': 'good', 'last_check': '1 hour ago'},
                {'domain': 'sendbree.com', 'spf': 'pass', 'dkim': 'pass', 'dmarc': 'warning', 'mx': 'pass', 'reputation': 'good', 'last_check': '2 hours ago'}
            ]
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


# ============================================================
# SETTINGS API
# ============================================================

@hub_bp.route('/hub/settings')
@login_required
def settings_page():
    return render_template('hub/settings.html')



# ============================================================
# ADVANCED USER MANAGEMENT API
# ============================================================

@hub_bp.route('/hub/api/users/list')
@login_required
def api_users_list():
    """Get all users with details"""
    try:
        conn = get_db()
        cur = conn.cursor(cursor_factory=RealDictCursor)
        
        cur.execute("""
            SELECT 
                u.id, u.email, u.name, u.role, u.status, u.created_at,
                o.name as organization,
                COUNT(DISTINCT e.id) as emails_sent,
                COUNT(DISTINCT c.id) as campaigns,
                COUNT(DISTINCT ct.id) as contacts
            FROM users u
            LEFT JOIN organizations o ON o.id = u.organization_id
            LEFT JOIN emails e ON e.organization_id = u.organization_id
            LEFT JOIN campaigns c ON c.organization_id = u.organization_id
            LEFT JOIN contacts ct ON ct.organization_id = u.organization_id
            GROUP BY u.id, u.email, u.name, u.role, u.status, u.created_at, o.name
            ORDER BY u.created_at DESC
            LIMIT 100
        """)
        users = []
        for row in cur.fetchall():
            user = dict(row)
            user['last_login'] = '2 hours ago'  # Would come from login tracking
            user['status'] = user.get('status') or 'active'
            user['role'] = user.get('role') or 'user'
            users.append(user)
        
        # Get organizations for filter
        cur.execute("SELECT id, name FROM organizations ORDER BY name")
        organizations = [dict(r) for r in cur.fetchall()]
        
        conn.close()
        
        return jsonify({
            'success': True,
            'users': users,
            'organizations': organizations,
            'stats': {
                'total': len(users),
                'active_today': sum(1 for u in users if u['status'] == 'active'),
                'new_week': 5,
                'suspended': sum(1 for u in users if u['status'] == 'suspended'),
                'pending_invites': 2
            }
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500



# ============================================================
# IP POOL MANAGEMENT ROUTES
# ============================================================

@hub_bp.route('/hub/ip-pools')
@login_required
def ip_pools():
    """IP Pool Management Dashboard"""
    return render_template('hub/ip_pools.html', active_page='ip_pools')


@hub_bp.route('/hub/ip-pools/api/overview')
@login_required
def ip_pools_overview():
    """Get IP pools overview stats"""
    conn = get_db()
    cur = conn.cursor(cursor_factory=RealDictCursor)
    
    try:
        cur.execute("""
            SELECT 
                COUNT(*) as total_ips,
                COUNT(*) FILTER (WHERE is_active AND NOT is_blacklisted) as active_ips,
                COUNT(*) FILTER (WHERE is_blacklisted) as blacklisted_ips,
                COUNT(*) FILTER (WHERE warmup_status = 'warming') as warming_ips,
                COUNT(*) FILTER (WHERE warmup_status = 'warmed') as warmed_ips,
                COALESCE(SUM(daily_limit), 0) as total_daily_capacity,
                COALESCE(SUM(sent_today), 0) as total_sent_today
            FROM sending_ips
        """)
        stats = dict(cur.fetchone())
        
        return jsonify({'overview': stats})
    except Exception as e:
        return jsonify({'error': str(e)}), 500
    finally:
        cur.close()
        conn.close()


@hub_bp.route('/hub/ip-pools/api/ips')
@login_required
def ip_pools_list():
    """Get all IPs with details"""
    conn = get_db()
    cur = conn.cursor(cursor_factory=RealDictCursor)
    
    try:
        cur.execute("""
            SELECT 
                si.*,
                ip.name as pool_name,
                ip.pool_type
            FROM sending_ips si
            LEFT JOIN ip_pools ip ON si.pool_id = ip.id
            ORDER BY ip.priority NULLS LAST, si.reputation_score DESC
        """)
        
        ips = []
        for row in cur.fetchall():
            ip = dict(row)
            for key in ['created_at', 'updated_at', 'last_sent_at', 'last_reset_at', 
                       'hour_reset_at', 'blacklist_checked_at', 'warmup_start_date']:
                if ip.get(key):
                    ip[key] = ip[key].isoformat() if hasattr(ip[key], 'isoformat') else str(ip[key])
            ips.append(ip)
        
        return jsonify({'ips': ips})
    except Exception as e:
        return jsonify({'error': str(e)}), 500
    finally:
        cur.close()
        conn.close()


@hub_bp.route('/hub/ip-pools/api/pools')
@login_required
def ip_pools_get():
    """Get all pools"""
    conn = get_db()
    cur = conn.cursor(cursor_factory=RealDictCursor)
    
    try:
        cur.execute("SELECT * FROM ip_pools ORDER BY priority")
        pools = [dict(row) for row in cur.fetchall()]
        return jsonify({'pools': pools})
    except Exception as e:
        return jsonify({'error': str(e)}), 500
    finally:
        cur.close()
        conn.close()


@hub_bp.route('/hub/ip-pools/api/ip', methods=['POST'])
@login_required
def ip_pools_add():
    """Add new IP"""
    data = request.json
    conn = get_db()
    cur = conn.cursor()
    
    try:
        # Get pool ID
        cur.execute("SELECT id FROM ip_pools WHERE name = %s", (data.get('pool_name', 'warmup'),))
        pool = cur.fetchone()
        pool_id = pool[0] if pool else None
        
        cur.execute("""
            INSERT INTO sending_ips (ip_address, hostname, pool_id, warmup_status, daily_limit, hourly_limit)
            VALUES (%s, %s, %s, 'new', 50, 10)
            ON CONFLICT (ip_address) DO UPDATE SET
                hostname = EXCLUDED.hostname,
                updated_at = NOW()
            RETURNING id
        """, (data['ip_address'], data.get('hostname'), pool_id))
        
        ip_id = cur.fetchone()[0]
        
        # Start warmup if requested
        if data.get('start_warmup'):
            cur.execute("""
                UPDATE sending_ips
                SET warmup_status = 'warming',
                    warmup_start_date = CURRENT_DATE,
                    warmup_day = 1,
                    daily_limit = 50,
                    hourly_limit = 10
                WHERE id = %s
            """, (ip_id,))
        
        conn.commit()
        return jsonify({'success': True, 'id': ip_id})
    except Exception as e:
        conn.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500
    finally:
        cur.close()
        conn.close()


@hub_bp.route('/hub/ip-pools/api/ip/<int:ip_id>', methods=['PUT'])
@login_required
def ip_pools_update(ip_id):
    """Update IP settings"""
    data = request.json
    conn = get_db()
    cur = conn.cursor()
    
    try:
        updates = []
        values = []
        
        allowed_fields = ['hostname', 'daily_limit', 'hourly_limit', 'is_active', 
                         'warmup_status', 'pool_id', 'reputation_score']
        
        for field in allowed_fields:
            if field in data:
                updates.append(f"{field} = %s")
                values.append(data[field])
        
        if updates:
            values.append(ip_id)
            cur.execute(f"""
                UPDATE sending_ips
                SET {', '.join(updates)}, updated_at = NOW()
                WHERE id = %s
            """, values)
            conn.commit()
        
        return jsonify({'success': True})
    except Exception as e:
        conn.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500
    finally:
        cur.close()
        conn.close()


@hub_bp.route('/hub/ip-pools/api/ip/<int:ip_id>/start-warmup', methods=['POST'])
@login_required
def ip_pools_start_warmup(ip_id):
    """Start warmup for an IP"""
    conn = get_db()
    cur = conn.cursor()
    
    try:
        # Get warmup pool ID
        cur.execute("SELECT id FROM ip_pools WHERE name = 'warmup'")
        pool = cur.fetchone()
        pool_id = pool[0] if pool else None
        
        cur.execute("""
            UPDATE sending_ips
            SET warmup_status = 'warming',
                warmup_start_date = CURRENT_DATE,
                warmup_day = 1,
                daily_limit = 50,
                hourly_limit = 10,
                pool_id = %s,
                updated_at = NOW()
            WHERE id = %s
        """, (pool_id, ip_id))
        conn.commit()
        
        return jsonify({'success': True})
    except Exception as e:
        conn.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500
    finally:
        cur.close()
        conn.close()


@hub_bp.route('/hub/ip-pools/api/ip/<int:ip_id>/check-blacklist', methods=['POST'])
@login_required
def ip_pools_check_blacklist(ip_id):
    """Check blacklist status for an IP"""
    import socket
    
    conn = get_db()
    cur = conn.cursor()
    
    try:
        cur.execute("SELECT ip_address FROM sending_ips WHERE id = %s", (ip_id,))
        row = cur.fetchone()
        if not row:
            return jsonify({'success': False, 'error': 'IP not found'}), 404
        
        ip_address = row[0]
        blacklists = {
            'spamhaus': 'zen.spamhaus.org',
            'barracuda': 'b.barracudacentral.org',
            'spamcop': 'bl.spamcop.net'
        }
        
        results = {'is_listed': False, 'listings': []}
        reversed_ip = '.'.join(reversed(ip_address.split('.')))
        
        for name, server in blacklists.items():
            try:
                query = f"{reversed_ip}.{server}"
                socket.gethostbyname(query)
                results['is_listed'] = True
                results['listings'].append(name)
            except socket.gaierror:
                pass
            except:
                pass
        
        # Update database
        cur.execute("""
            UPDATE sending_ips
            SET is_blacklisted = %s,
                blacklist_checked_at = NOW(),
                blacklist_details = %s
            WHERE id = %s
        """, (results['is_listed'], json.dumps(results), ip_id))
        conn.commit()
        
        return jsonify({'success': True, 'result': results})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500
    finally:
        cur.close()
        conn.close()


@hub_bp.route('/hub/ip-pools/api/check-all-blacklists', methods=['POST'])
@login_required
def ip_pools_check_all_blacklists():
    """Check blacklist status for all IPs"""
    import socket
    
    conn = get_db()
    cur = conn.cursor()
    
    try:
        cur.execute("SELECT id, ip_address FROM sending_ips WHERE is_active = true")
        all_ips = cur.fetchall()
        
        blacklists = {
            'spamhaus': 'zen.spamhaus.org',
            'barracuda': 'b.barracudacentral.org',
            'spamcop': 'bl.spamcop.net'
        }
        
        results = []
        
        for ip_id, ip_address in all_ips:
            ip_results = {'ip': ip_address, 'is_listed': False, 'listings': []}
            reversed_ip = '.'.join(reversed(ip_address.split('.')))
            
            for name, server in blacklists.items():
                try:
                    query = f"{reversed_ip}.{server}"
                    socket.gethostbyname(query)
                    ip_results['is_listed'] = True
                    ip_results['listings'].append(name)
                except:
                    pass
            
            # Update database
            cur.execute("""
                UPDATE sending_ips
                SET is_blacklisted = %s,
                    blacklist_checked_at = NOW(),
                    blacklist_details = %s
                WHERE id = %s
            """, (ip_results['is_listed'], json.dumps(ip_results), ip_id))
            
            results.append(ip_results)
        
        conn.commit()
        return jsonify({'success': True, 'results': results})
    except Exception as e:
        conn.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500
    finally:
        cur.close()
        conn.close()


@hub_bp.route('/hub/ip-pools/api/progress-warmup', methods=['POST'])
@login_required
def ip_pools_progress_warmup():
    """Progress warmup for all warming IPs"""
    conn = get_db()
    cur = conn.cursor(cursor_factory=RealDictCursor)
    
    WARMUP_SCHEDULE = {
        1: 50, 2: 75, 3: 100, 4: 150, 5: 200,
        6: 300, 7: 400, 8: 500, 9: 650, 10: 800,
        11: 1000, 12: 1250, 13: 1500, 14: 2000,
        15: 2500, 16: 3000, 17: 4000, 18: 5000,
        19: 6500, 20: 8000, 21: 10000, 25: 15000,
        28: 20000, 30: 30000, 35: 50000, 42: 75000,
        45: 100000
    }
    
    try:
        cur.execute("""
            SELECT id, ip_address, warmup_day, warmup_start_date
            FROM sending_ips
            WHERE warmup_status = 'warming'
        """)
        
        for ip in cur.fetchall():
            new_day = (ip['warmup_day'] or 0) + 1
            
            # Get new limits
            daily_limit = 50
            for day, limit in sorted(WARMUP_SCHEDULE.items()):
                if new_day >= day:
                    daily_limit = limit
            
            hourly_limit = daily_limit // 6
            status = 'warmed' if daily_limit >= 100000 else 'warming'
            
            cur.execute("""
                UPDATE sending_ips
                SET warmup_day = %s,
                    daily_limit = %s,
                    hourly_limit = %s,
                    warmup_status = %s,
                    updated_at = NOW()
                WHERE id = %s
            """, (new_day, daily_limit, hourly_limit, status, ip['id']))
        
        conn.commit()
        return jsonify({'success': True})
    except Exception as e:
        conn.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500
    finally:
        cur.close()
        conn.close()


@hub_bp.route('/hub/ip-pools/api/reset-counters', methods=['POST'])
@login_required
def ip_pools_reset_counters():
    """Reset daily/hourly counters"""
    data = request.json or {}
    reset_type = data.get('type', 'daily')
    
    conn = get_db()
    cur = conn.cursor()
    
    try:
        if reset_type == 'daily':
            cur.execute("UPDATE sending_ips SET sent_today = 0, last_reset_at = NOW()")
        else:
            cur.execute("UPDATE sending_ips SET sent_this_hour = 0, hour_reset_at = NOW()")
        
        conn.commit()
        return jsonify({'success': True})
    except Exception as e:
        conn.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500
    finally:
        cur.close()
        conn.close()


@hub_bp.route('/hub/ip-pools/api/warmup-schedule')
@login_required
def ip_pools_warmup_schedule():
    """Get warmup schedule"""
    conn = get_db()
    cur = conn.cursor(cursor_factory=RealDictCursor)
    
    try:
        cur.execute("SELECT * FROM ip_warmup_schedule ORDER BY day_number")
        schedule = [dict(row) for row in cur.fetchall()]
        return jsonify({'schedule': schedule})
    except Exception as e:
        return jsonify({'error': str(e)}), 500
    finally:
        cur.close()
        conn.close()


@hub_bp.route('/hub/ip-pools/api/content-rules')
@login_required
def ip_pools_content_rules():
    """Get content filter rules"""
    conn = get_db()
    cur = conn.cursor(cursor_factory=RealDictCursor)
    
    try:
        cur.execute("SELECT * FROM content_filter_rules ORDER BY score_impact DESC")
        rules = [dict(row) for row in cur.fetchall()]
        return jsonify({'rules': rules})
    except Exception as e:
        return jsonify({'error': str(e)}), 500
    finally:
        cur.close()
        conn.close()


# ============================================================
# SYSTEM ADMINISTRATION API ROUTES
# ============================================================

@hub_bp.route('/hub/system-admin')
@login_required
def system_admin():
    """System Administration Dashboard"""
    return render_template('hub/system_admin.html', active_page='system_admin')


@hub_bp.route('/hub/api/system/ips')
@login_required
def api_system_ips():
    """Get all IPs from ip_pools table"""
    conn = get_db()
    cur = conn.cursor(cursor_factory=RealDictCursor)
    
    try:
        cur.execute("""
            SELECT * FROM ip_pools 
            ORDER BY priority, warmup_day DESC, daily_limit DESC
        """)
        ips = [dict(row) for row in cur.fetchall()]
        
        # Convert datetime objects
        for ip in ips:
            for key in ['last_used_at', 'last_reset_at', 'created_at']:
                if ip.get(key):
                    ip[key] = ip[key].isoformat() if hasattr(ip[key], 'isoformat') else str(ip[key])
        
        return jsonify({'ips': ips})
    except Exception as e:
        return jsonify({'error': str(e)}), 500
    finally:
        cur.close()
        conn.close()


@hub_bp.route('/hub/api/system/ips', methods=['POST'])
@login_required
def api_system_add_ip():
    """Add new IP"""
    data = request.json
    conn = get_db()
    cur = conn.cursor()
    
    try:
        cur.execute("""
            INSERT INTO ip_pools (ip_address, hostname, daily_limit, warmup_day, priority, is_active)
            VALUES (%s, %s, %s, %s, %s, true)
            ON CONFLICT (ip_address) DO UPDATE SET
                hostname = EXCLUDED.hostname,
                daily_limit = EXCLUDED.daily_limit
            RETURNING id
        """, (
            data['ip_address'],
            data.get('hostname'),
            int(data.get('daily_limit', 500)),
            int(data.get('warmup_day', 1)),
            int(data.get('priority', 2))
        ))
        conn.commit()
        return jsonify({'success': True})
    except Exception as e:
        conn.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500
    finally:
        cur.close()
        conn.close()


@hub_bp.route('/hub/api/system/ips/<int:ip_id>', methods=['PUT'])
@login_required
def api_system_update_ip(ip_id):
    """Update IP settings"""
    data = request.json
    conn = get_db()
    cur = conn.cursor()
    
    try:
        updates = []
        values = []
        
        for field in ['hostname', 'daily_limit', 'warmup_day', 'priority', 'is_active', 'sent_today']:
            if field in data:
                updates.append(f"{field} = %s")
                values.append(data[field])
        
        if updates:
            values.append(ip_id)
            cur.execute(f"UPDATE ip_pools SET {', '.join(updates)} WHERE id = %s", values)
            conn.commit()
        
        return jsonify({'success': True})
    except Exception as e:
        conn.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500
    finally:
        cur.close()
        conn.close()


@hub_bp.route('/hub/api/system/check-blacklist', methods=['POST'])
@login_required
def api_system_check_blacklist():
    """Check single IP blacklist status"""
    import socket
    
    data = request.json
    ip_address = data.get('ip_address')
    
    blacklists = {
        'spamhaus': 'zen.spamhaus.org',
        'barracuda': 'b.barracudacentral.org',
        'spamcop': 'bl.spamcop.net'
    }
    
    result = {'ip': ip_address, 'is_listed': False, 'listings': []}
    reversed_ip = '.'.join(reversed(ip_address.split('.')))
    
    for name, server in blacklists.items():
        try:
            query = f"{reversed_ip}.{server}"
            socket.gethostbyname(query)
            result['is_listed'] = True
            result['listings'].append(name)
        except socket.gaierror:
            pass
        except:
            pass
    
    return jsonify(result)


@hub_bp.route('/hub/api/system/check-all-blacklists', methods=['POST'])
@login_required
def api_system_check_all_blacklists():
    """Check all IPs for blacklist status"""
    import socket
    
    conn = get_db()
    cur = conn.cursor()
    
    try:
        cur.execute("SELECT ip_address FROM ip_pools WHERE is_active = true")
        all_ips = [row[0] for row in cur.fetchall()]
        
        blacklists = {
            'spamhaus': 'zen.spamhaus.org',
            'barracuda': 'b.barracudacentral.org',
            'spamcop': 'bl.spamcop.net'
        }
        
        results = []
        for ip_address in all_ips:
            result = {'ip': ip_address, 'is_listed': False, 'listings': []}
            reversed_ip = '.'.join(reversed(ip_address.split('.')))
            
            for name, server in blacklists.items():
                try:
                    query = f"{reversed_ip}.{server}"
                    socket.gethostbyname(query)
                    result['is_listed'] = True
                    result['listings'].append(name)
                except:
                    pass
            
            results.append(result)
        
        return jsonify({'results': results})
    finally:
        cur.close()
        conn.close()


@hub_bp.route('/hub/api/system/reset-counters', methods=['POST'])
@login_required
def api_system_reset_counters():
    """Reset daily counters"""
    conn = get_db()
    cur = conn.cursor()
    
    try:
        cur.execute("UPDATE ip_pools SET sent_today = 0, last_reset_at = NOW()")
        conn.commit()
        return jsonify({'success': True})
    except Exception as e:
        conn.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500
    finally:
        cur.close()
        conn.close()


@hub_bp.route('/hub/api/system/workers')
@login_required
def api_system_workers():
    """Get Celery workers status"""
    import subprocess
    
    workers = []
    online = 0
    active_tasks = 0
    queued = 0
    queues = {}
    
    try:
        # Get worker status via celery inspect
        result = subprocess.run(
            ['celery', '-A', 'celery_app', 'inspect', 'ping', '--timeout=5'],
            capture_output=True, text=True, timeout=15, cwd='/opt/sendbaba-staging'
        )
        
        # Parse output
        for line in result.stdout.split('\n'):
            if 'worker@' in line and 'OK' in line:
                worker_name = line.split('->')[0].strip().replace('-', '')
                workers.append({
                    'name': worker_name.split('@')[-1] if '@' in worker_name else worker_name,
                    'hostname': worker_name,
                    'status': 'online',
                    'active_tasks': 0
                })
                online += 1
        
        # Get active tasks
        result2 = subprocess.run(
            ['celery', '-A', 'celery_app', 'inspect', 'active', '--timeout=5'],
            capture_output=True, text=True, timeout=15, cwd='/opt/sendbaba-staging'
        )
        
        # Count active tasks (rough estimate from output)
        active_tasks = result2.stdout.count("'id':")
        
        # Get queue lengths from Redis
        try:
            r = get_redis()
            for key in r.keys('*'):
                key_str = key.decode() if isinstance(key, bytes) else key
                if 'celery' in key_str.lower() or 'email' in key_str.lower():
                    try:
                        length = r.llen(key)
                        if length > 0:
                            queues[key_str] = length
                            queued += length
                    except:
                        pass
        except:
            pass
        
    except subprocess.TimeoutExpired:
        pass
    except Exception as e:
        print(f"Worker check error: {e}")
    
    return jsonify({
        'workers': workers,
        'online': online,
        'active_tasks': active_tasks,
        'queued': queued,
        'queues': queues,
        'beat_status': None  # TODO: Add beat status check
    })


@hub_bp.route('/hub/api/system/ping-workers', methods=['POST'])
@login_required
def api_system_ping_workers():
    """Ping all Celery workers"""
    import subprocess
    
    try:
        result = subprocess.run(
            ['celery', '-A', 'celery_app', 'inspect', 'ping', '--timeout=10'],
            capture_output=True, text=True, timeout=20, cwd='/opt/sendbaba-staging'
        )
        
        responded = result.stdout.count('pong')
        return jsonify({'responded': responded, 'output': result.stdout[:500]})
    except Exception as e:
        return jsonify({'responded': 0, 'error': str(e)})


@hub_bp.route('/hub/api/system/check-dns', methods=['POST'])
@login_required
def api_system_check_dns():
    """Check DNS records for a domain"""
    import dns.resolver
    
    data = request.json
    domain = data.get('domain', '').strip().lower()
    
    result = {
        'domain': domain,
        'spf': {'found': False, 'value': '', 'valid': False},
        'dkim': {'found': False, 'value': ''},
        'dmarc': {'found': False, 'value': ''},
        'mx': []
    }
    
    # Check SPF
    try:
        answers = dns.resolver.resolve(domain, 'TXT', lifetime=10)
        for rdata in answers:
            txt = str(rdata).strip('"')
            if 'v=spf1' in txt:
                result['spf'] = {
                    'found': True,
                    'value': txt,
                    'valid': '_spf.sendbaba.com' in txt or 'sendbaba' in txt.lower()
                }
                break
    except:
        pass
    
    # Check DKIM
    for selector in ['mail', 'default', 'sendbaba', 'google', 'selector1', 'selector2']:
        try:
            dkim_domain = f'{selector}._domainkey.{domain}'
            answers = dns.resolver.resolve(dkim_domain, 'TXT', lifetime=5)
            for rdata in answers:
                txt = str(rdata).strip('"')
                if 'DKIM1' in txt or 'k=rsa' in txt:
                    result['dkim'] = {'found': True, 'value': txt, 'selector': selector}
                    break
            if result['dkim']['found']:
                break
        except:
            pass
    
    # Check DMARC
    try:
        dmarc_domain = f'_dmarc.{domain}'
        answers = dns.resolver.resolve(dmarc_domain, 'TXT', lifetime=10)
        for rdata in answers:
            txt = str(rdata).strip('"')
            if 'DMARC1' in txt:
                result['dmarc'] = {'found': True, 'value': txt}
                break
    except:
        pass
    
    # Check MX
    try:
        answers = dns.resolver.resolve(domain, 'MX', lifetime=10)
        result['mx'] = [f"{r.preference} {r.exchange}" for r in answers]
    except:
        pass
    
    return jsonify(result)


@hub_bp.route('/hub/api/system/client-domains')
@login_required
def api_system_client_domains():
    """Get all client domains"""
    conn = get_db()
    cur = conn.cursor(cursor_factory=RealDictCursor)
    
    try:
        cur.execute("""
            SELECT 
                d.domain_name,
                d.dns_verified,
                d.spf_valid,
                d.dkim_valid,
                d.dmarc_valid,
                o.name as org_name
            FROM domains d
            LEFT JOIN organizations o ON d.organization_id = o.id
            ORDER BY d.created_at DESC
        """)
        domains = [dict(row) for row in cur.fetchall()]
        return jsonify({'domains': domains})
    except Exception as e:
        return jsonify({'error': str(e)}), 500
    finally:
        cur.close()
        conn.close()


@hub_bp.route('/hub/api/system/environment')
@login_required
def api_system_environment():
    """Get safe environment variables"""
    import os
    
    # Only show safe env vars (not secrets)
    safe_vars = [
        'FLASK_ENV', 'DATABASE_URL', 'REDIS_URL', 'CELERY_BROKER_URL',
        'MAIL_SERVER', 'MAIL_PORT', 'LOG_LEVEL', 'DEBUG',
        'PYTHONPATH', 'PATH', 'HOME', 'USER'
    ]
    
    env = {}
    for key in safe_vars:
        if key in os.environ:
            value = os.environ[key]
            # Mask sensitive parts
            if 'PASSWORD' in key.upper() or 'SECRET' in key.upper():
                value = '***HIDDEN***'
            elif '@' in value:
                # Mask password in connection strings
                parts = value.split('@')
                if len(parts) > 1:
                    value = parts[0].split(':')[0] + ':***@' + parts[1]
            env[key] = value
    
    return jsonify({'env': env})


@hub_bp.route('/hub/api/system/info')
@login_required
def api_system_info():
    """Get system info"""
    import subprocess
    
    result = {
        'cpu_percent': 0,
        'memory_percent': 0,
        'disk_percent': 0,
        'uptime': '-'
    }
    
    try:
        # CPU usage
        cpu = subprocess.run(['grep', 'cpu ', '/proc/stat'], capture_output=True, text=True)
        
        # Memory usage
        mem = subprocess.run(['free', '-m'], capture_output=True, text=True)
        for line in mem.stdout.split('\n'):
            if 'Mem:' in line:
                parts = line.split()
                if len(parts) >= 3:
                    total = int(parts[1])
                    used = int(parts[2])
                    result['memory_percent'] = round(used / total * 100)
        
        # Disk usage
        disk = subprocess.run(['df', '-h', '/'], capture_output=True, text=True)
        for line in disk.stdout.split('\n'):
            if '/' in line and not line.startswith('Filesystem'):
                parts = line.split()
                if len(parts) >= 5:
                    result['disk_percent'] = int(parts[4].replace('%', ''))
        
        # Uptime
        uptime = subprocess.run(['uptime', '-p'], capture_output=True, text=True)
        result['uptime'] = uptime.stdout.strip().replace('up ', '')
        
    except Exception as e:
        print(f"System info error: {e}")
    
    return jsonify(result)
