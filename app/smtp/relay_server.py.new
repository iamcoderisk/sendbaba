"""
SendBaba Professional SMTP Relay Server
========================================
Multi-tenant email sending platform with:
- Multi-domain DKIM signing (from database)
- IP rotation for warmup/limits
- Per-organization domain support
- Full TLS encryption
- Automatic retry logic

This is a SendGrid/Mailchimp-like architecture supporting thousands of users,
each with their own verified domains and DKIM keys.

Usage (unchanged - backward compatible):
    from app.smtp.relay_server import send_email_sync
    result = send_email_sync({
        'from': 'sender@customerdomain.com',
        'to': 'recipient@example.com',
        'subject': 'Hello',
        'html_body': '<p>Hello World</p>'
    })
"""

import smtplib
import ssl
import dns.resolver
import logging
import os
import sys
import time
import re
import threading
from typing import Dict, Tuple, Optional

from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.utils import make_msgid, formatdate

sys.path.insert(0, '/opt/sendbaba-staging')

# =============================================================================
# OPTIONAL DEPENDENCIES
# =============================================================================
try:
    import dkim
    DKIM_AVAILABLE = True
except ImportError:
    DKIM_AVAILABLE = False
    logging.warning("dkim module not available")

try:
    from premailer import transform as inline_css
    HAS_PREMAILER = True
except ImportError:
    HAS_PREMAILER = False

try:
    from app.utils.ip_rotation import get_ip_for_sending, get_ip_stats
    IP_ROTATION_AVAILABLE = True
except ImportError:
    IP_ROTATION_AVAILABLE = False

try:
    import psycopg2
    from psycopg2.extras import RealDictCursor
    DB_AVAILABLE = True
except ImportError:
    DB_AVAILABLE = False

logger = logging.getLogger(__name__)

# =============================================================================
# CONFIGURATION
# =============================================================================
DB_CONFIG = {
    'host': 'localhost',
    'database': 'emailer',
    'user': 'emailer',
    'password': 'SecurePassword123'
}

DKIM_KEY_DIR = '/opt/sendbaba-staging/data/dkim'
DEFAULT_HOSTNAME = 'mail.sendbaba.com'
DEFAULT_DKIM_SELECTOR = 'mail'


# =============================================================================
# DATABASE CONNECTION POOL
# =============================================================================
class DatabasePool:
    """Simple connection pool for database queries"""
    _instance = None
    _lock = threading.Lock()
    
    def __new__(cls):
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
                    cls._instance._initialized = False
        return cls._instance
    
    def __init__(self):
        if self._initialized:
            return
        self._initialized = True
        self._connection = None
    
    def get_connection(self):
        """Get database connection"""
        try:
            if self._connection is None or self._connection.closed:
                self._connection = psycopg2.connect(**DB_CONFIG)
            return self._connection
        except Exception as e:
            logger.error(f"Database connection failed: {e}")
            return None
    
    def execute_query(self, query, params=None):
        """Execute query and return results"""
        conn = self.get_connection()
        if not conn:
            return None
        try:
            with conn.cursor(cursor_factory=RealDictCursor) as cur:
                cur.execute(query, params)
                return cur.fetchall()
        except Exception as e:
            logger.error(f"Query failed: {e}")
            try:
                conn.rollback()
            except:
                pass
            return None


db_pool = DatabasePool() if DB_AVAILABLE else None


# =============================================================================
# MULTI-TENANT DKIM MANAGER
# =============================================================================
class MultiTenantDKIM:
    """
    Multi-tenant DKIM signing manager.
    
    Loads DKIM keys from:
    1. Database (domains table - dkim_private_key column) - PRIMARY
    2. File system (data/dkim/{domain}_private.key) - FALLBACK
    
    Supports thousands of domains, each with their own DKIM keys.
    """
    
    def __init__(self):
        self._cache = {}  # domain -> (private_key, selector, timestamp)
        self._cache_ttl = 3600  # 1 hour cache
        self._lock = threading.Lock()
    
    def _load_from_database(self, domain: str) -> Tuple[Optional[bytes], str]:
        """Load DKIM key from database"""
        if not db_pool:
            return None, DEFAULT_DKIM_SELECTOR
        
        try:
            results = db_pool.execute_query("""
                SELECT dkim_private_key, dkim_selector 
                FROM domains 
                WHERE domain_name = %s AND dkim_private_key IS NOT NULL
                LIMIT 1
            """, (domain,))
            
            if results and results[0]['dkim_private_key']:
                key = results[0]['dkim_private_key']
                selector = results[0]['dkim_selector'] or DEFAULT_DKIM_SELECTOR
                
                # Convert to bytes if string
                if isinstance(key, str):
                    key = key.encode('utf-8')
                
                logger.info(f"âœ… DKIM loaded from DB: {domain}")
                return key, selector
        except Exception as e:
            logger.warning(f"DB DKIM load failed for {domain}: {e}")
        
        return None, DEFAULT_DKIM_SELECTOR
    
    def _load_from_file(self, domain: str) -> Tuple[Optional[bytes], str]:
        """Load DKIM key from file system (fallback)"""
        key_path = f'{DKIM_KEY_DIR}/{domain}_private.key'
        
        try:
            if os.path.exists(key_path):
                with open(key_path, 'rb') as f:
                    key = f.read()
                logger.info(f"âœ… DKIM loaded from file: {domain}")
                return key, DEFAULT_DKIM_SELECTOR
        except Exception as e:
            logger.warning(f"File DKIM load failed for {domain}: {e}")
        
        return None, DEFAULT_DKIM_SELECTOR
    
    def get_dkim_key(self, domain: str) -> Tuple[Optional[bytes], str]:
        """
        Get DKIM private key and selector for a domain.
        Uses caching to avoid repeated database/file lookups.
        
        Returns: (private_key_bytes, selector)
        """
        with self._lock:
            # Check cache
            if domain in self._cache:
                key, selector, timestamp = self._cache[domain]
                if time.time() - timestamp < self._cache_ttl:
                    return key, selector
            
            # Load from database first
            key, selector = self._load_from_database(domain)
            
            # Fallback to file if not in database
            if not key:
                key, selector = self._load_from_file(domain)
            
            # Cache the result (even if None, to avoid repeated lookups)
            self._cache[domain] = (key, selector, time.time())
            
            return key, selector
    
    def sign(self, message_bytes: bytes, domain: str) -> bytes:
        """
        Sign message with DKIM for the specified domain.
        
        Args:
            message_bytes: Raw email message as bytes
            domain: Sender domain to sign for
        
        Returns:
            Signed message bytes (or original if signing fails)
        """
        if not DKIM_AVAILABLE:
            return message_bytes
        
        private_key, selector = self.get_dkim_key(domain)
        
        if not private_key:
            logger.warning(f"No DKIM key for {domain}")
            return message_bytes
        
        try:
            signature = dkim.sign(
                message=message_bytes,
                selector=selector.encode('utf-8'),
                domain=domain.encode('utf-8'),
                privkey=private_key,
                include_headers=[b'from', b'to', b'subject', b'date', b'message-id']
            )
            
            if signature and signature != message_bytes:
                logger.info(f"âœ… DKIM signed: {domain}")
                return signature + message_bytes
            
            return message_bytes
        except Exception as e:
            logger.error(f"DKIM signing failed for {domain}: {e}")
            return message_bytes
    
    def clear_cache(self, domain: str = None):
        """Clear DKIM cache for a domain or all domains"""
        with self._lock:
            if domain:
                self._cache.pop(domain, None)
            else:
                self._cache.clear()


# Global DKIM manager instance
dkim_manager = MultiTenantDKIM()


# =============================================================================
# PROFESSIONAL SMTP RELAY
# =============================================================================
class ProfessionalSMTPRelay:
    """
    Multi-tenant SMTP Relay with IP Rotation
    
    Features:
    - Multi-domain DKIM signing (database + file fallback)
    - IP rotation for warmup tracking
    - MX record caching
    - TLS encryption
    - Automatic retry logic
    - Support for thousands of customer domains
    """
    
    def __init__(self):
        self.mx_cache = {}
        self.hostname = DEFAULT_HOSTNAME
        logger.info("âœ… SMTP Relay initialized (Multi-tenant)" + 
                   (" + IP Rotation" if IP_ROTATION_AVAILABLE else ""))
    
    def get_mx_servers(self, domain: str) -> list:
        """Get MX servers for domain with caching"""
        if domain in self.mx_cache:
            cache_time, mx_list = self.mx_cache[domain]
            if time.time() - cache_time < 3600:  # 1 hour cache
                return mx_list
        try:
            mx_records = dns.resolver.resolve(domain, 'MX')
            mx_list = [str(r.exchange).rstrip('.') for r in sorted(mx_records, key=lambda x: x.preference)]
            self.mx_cache[domain] = (time.time(), mx_list)
            logger.info(f"MX: {mx_list[:2]}")
            return mx_list
        except Exception as e:
            logger.error(f"MX failed for {domain}: {e}")
            return []
    
    def get_next_ip(self) -> Tuple[str, str]:
        """Get next IP from rotation pool for tracking"""
        if IP_ROTATION_AVAILABLE:
            try:
                ip, hostname = get_ip_for_sending()
                if ip:
                    return ip, hostname or DEFAULT_HOSTNAME
            except Exception as e:
                logger.warning(f"IP rotation error: {e}")
        return None, DEFAULT_HOSTNAME
    
    def create_message(self, email_data: dict) -> Tuple[bytes, str]:
        """
        Create email message with proper headers and DKIM signing.
        Supports any domain registered in the system.
        
        Returns: (signed_message_bytes, sender_domain)
        """
        msg = MIMEMultipart('alternative')
        
        # =================================================================
        # PARSE SENDER (supports any customer domain)
        # =================================================================
        sender = email_data.get('from') or email_data.get('from_email') or 'noreply@sendbaba.com'
        if not sender or '@' not in str(sender):
            sender = 'noreply@sendbaba.com'
        sender = str(sender).strip()
        
        try:
            sender_domain = sender.split('@')[1] if '@' in sender else 'sendbaba.com'
        except:
            sender_domain = 'sendbaba.com'
        
        # Parse from_name
        from_name = email_data.get('from_name') or sender_domain.split('.')[0].title()
        from_name = str(from_name).strip() if from_name else 'SendBaba'
        
        recipient = email_data.get('to') or email_data.get('to_email')
        
        logger.info(f"From: {from_name} <{sender}>")
        
        # =================================================================
        # HEADERS - Optimized for deliverability
        # =================================================================
        msg['From'] = f'{from_name} <{sender}>'
        msg['To'] = recipient
        msg['Subject'] = email_data.get('subject', 'Message')
        msg['Date'] = formatdate(localtime=True)
        msg['Message-ID'] = make_msgid(domain=sender_domain)
        msg['MIME-Version'] = '1.0'
        msg['Return-Path'] = f'bounces@{sender_domain}'
        
        # Reply-To
        reply_to = email_data.get('reply_to', sender)
        msg['Reply-To'] = reply_to
        
        # List-Unsubscribe (improves deliverability)
        unsubscribe_url = email_data.get('unsubscribe_url') or \
                          f'https://{sender_domain}/unsubscribe?email={recipient}'
        msg['List-Unsubscribe'] = f'<{unsubscribe_url}>'
        msg['List-Unsubscribe-Post'] = 'List-Unsubscribe=One-Click'
        msg['Precedence'] = 'bulk'
        
        # =================================================================
        # BODY
        # =================================================================
        text_body = email_data.get('text_body', '')
        html_body = email_data.get('html_body', '')
        
        # Generate text from HTML if not provided
        if not text_body and html_body:
            text_body = re.sub('<[^<]+?>', '', html_body).strip()
        
        if text_body:
            msg.attach(MIMEText(text_body, 'plain', 'utf-8'))
        
        if html_body:
            # Inline CSS for better email client compatibility
            if HAS_PREMAILER:
                try:
                    html_body = inline_css(html_body, remove_classes=True, strip_important=False)
                except:
                    pass
            msg.attach(MIMEText(html_body, 'html', 'utf-8'))
        elif not text_body:
            msg.attach(MIMEText('Message from ' + sender_domain, 'plain', 'utf-8'))
        
        # =================================================================
        # DKIM SIGNING (uses sender's domain key from database)
        # =================================================================
        message_bytes = msg.as_bytes()
        signed_message = dkim_manager.sign(message_bytes, sender_domain)
        
        return signed_message, sender_domain
    
    def send_email(self, email_data: dict, retry_count: int = 0) -> Dict:
        """
        Send email with multi-tenant DKIM and IP rotation.
        
        Args:
            email_data: Dict with from, to, subject, html_body, text_body
            retry_count: Current retry attempt (internal use)
        
        Returns:
            Dict with success, message, mx_server, tls, source_ip
        """
        recipient = email_data.get('to') or email_data.get('to_email', '')
        recipient = str(recipient).strip()
        
        sender = email_data.get('from') or email_data.get('from_email') or 'noreply@sendbaba.com'
        if not sender or '@' not in str(sender):
            sender = 'noreply@sendbaba.com'
        
        # Validate recipient
        if not recipient or '@' not in recipient:
            return {'success': False, 'message': 'Invalid recipient'}
        
        try:
            recipient_domain = recipient.split('@')[1]
        except:
            return {'success': False, 'message': 'Invalid format'}
        
        # =================================================================
        # IP ROTATION - Track which IP is used
        # =================================================================
        tracked_ip, tracked_hostname = self.get_next_ip()
        if tracked_ip:
            logger.info(f"ðŸ“Š IP: {tracked_ip}")
        
        # Get MX servers
        mx_servers = self.get_mx_servers(recipient_domain)
        if not mx_servers:
            return {'success': False, 'message': 'No MX', 'source_ip': tracked_ip}
        
        # Create signed message (DKIM signed for sender's domain)
        signed_message, sender_domain = self.create_message(email_data)
        
        # =================================================================
        # SEND VIA SMTP
        # =================================================================
        for mx_server in mx_servers[:3]:
            try:
                logger.info(f"ðŸ“¤ {mx_server}")
                
                # Connect
                smtp = smtplib.SMTP(mx_server, 25, timeout=30)
                smtp.ehlo(self.hostname)
                
                # TLS
                tls_used = False
                if smtp.has_extn('STARTTLS'):
                    try:
                        context = ssl.create_default_context()
                        context.check_hostname = False
                        context.verify_mode = ssl.CERT_NONE
                        smtp.starttls(context=context)
                        smtp.ehlo(self.hostname)
                        logger.info("âœ… TLS enabled")
                        tls_used = True
                    except Exception as tls_err:
                        logger.warning(f"TLS failed: {tls_err}")
                
                # Send
                smtp.sendmail(sender, [recipient], signed_message)
                smtp.quit()
                
                logger.info(f"âœ… Sent to {recipient} successfully")
                return {
                    'success': True,
                    'message': 'Email sent',
                    'mx_server': mx_server,
                    'tls': tls_used,
                    'encrypted': tls_used,
                    'source_ip': tracked_ip,
                    'domain': sender_domain
                }
                
            except Exception as e:
                logger.warning(f"Failed: {e}")
                try:
                    smtp.quit()
                except:
                    pass
                continue
        
        # Retry logic
        if retry_count < 2:
            time.sleep(2 ** retry_count)
            return self.send_email(email_data, retry_count + 1)
        
        return {'success': False, 'message': 'All MX failed', 'source_ip': tracked_ip}


# =============================================================================
# GLOBAL RELAY INSTANCE
# =============================================================================
relay = ProfessionalSMTPRelay()


# =============================================================================
# PUBLIC API (Backward compatible)
# =============================================================================
def send_email_sync(email_data: dict) -> dict:
    """
    Send email synchronously.
    
    This is the main function called by Celery tasks.
    Supports any domain registered in the system.
    
    Args:
        email_data: Dict with:
            - from: Sender email (any verified domain)
            - from_name: Sender display name
            - to: Recipient email
            - subject: Email subject
            - html_body: HTML content
            - text_body: Plain text content (optional)
            - reply_to: Reply-to address (optional)
    
    Returns:
        Dict with success, message, mx_server, tls, source_ip, domain
    """
    return relay.send_email(email_data)


async def send_via_relay(email_data: dict) -> dict:
    """Async wrapper for send_email (for compatibility)"""
    return relay.send_email(email_data)


def get_relay_stats() -> dict:
    """Get relay and IP rotation statistics"""
    stats = {
        'relay_initialized': True,
        'dkim_available': DKIM_AVAILABLE,
        'ip_rotation_available': IP_ROTATION_AVAILABLE,
        'premailer_available': HAS_PREMAILER,
        'database_available': DB_AVAILABLE
    }
    
    if IP_ROTATION_AVAILABLE:
        try:
            ip_stats = list(get_ip_stats())
            stats['ip_pool'] = {
                'total': len(ip_stats),
                'active': sum(1 for ip in ip_stats if ip['is_active']),
                'sent_today': sum(ip['sent_today'] for ip in ip_stats),
                'ips': ip_stats
            }
        except:
            pass
    
    return stats


def clear_dkim_cache(domain: str = None):
    """Clear DKIM cache (call after domain verification changes)"""
    dkim_manager.clear_cache(domain)
    logger.info(f"DKIM cache cleared: {domain or 'all'}")
